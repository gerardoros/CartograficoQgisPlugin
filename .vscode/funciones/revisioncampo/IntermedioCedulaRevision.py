# -*- coding: utf-8 -*-
"""
/***************************************************************************
 IntermedioCedulaRevision
                                 A QGIS plugin
 IntermedioCedulaRevision
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-06-22
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Charro
        email                : mramirez.worknest@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is not free software; you cannot redistribute nor modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction, QMessageBox
from PyQt5 import QtWidgets
from PyQt5 import QtCore

# Initialize Qt resources from file resources.py

# Import the code for the dialog
from .IntermedioCedulaRevision_dialog import IntermedioCedulaRevisionDialog
from .CedulaPadron import CedulaPadron
from ..consulta.Cedula_MainWindow import CedulaMainWindow
import os.path
import os.path
from qgis.utils import *
import os, json, requests
from osgeo import ogr, osr

class IntermedioCedulaRevision:
    """QGIS Plugin Implementation."""

    def __init__(self, iface, pluginM, tipo):

        # Save reference to the QGIS interface
        self.iface = iface
        self.tipo = tipo
        self.pluginM = pluginM
        self.dlg = IntermedioCedulaRevisionDialog()

        self.dlg.tablaClaves.doubleClicked.connect(self.abrirCedula)
        self.dlg.tablaClaves.setEditTriggers(QtWidgets.QTableWidget.NoEditTriggers)

        self.cedulaPadron = CedulaPadron(iface, self)

        self.cveCatastral = ''
        self.idPredio = ''

        self.listaCedula = {}
        self.dlg.tablaClaves.hideColumn(0)
        self.dlg.cmbManzana.currentIndexChanged.connect(self.llenarTabla)

        if self.tipo == 'PAD':
            self.dlg.setWindowTitle('Revision de Padron')
        elif self.tipo == 'REV':
            self.dlg.setWindowTitle('Revision de Gabinete')

        self.muestrate = False
        #self.dlg.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)


    def run(self):
        """Run method that performs all the real work"""
        # show the dialog
        self.pluginM.UTI.strechtTabla(self.dlg.tablaClaves)
        self.usuarioLogeado = 'jaz'
        #self.llenarTabla()
        self.llenarCombito()

        if self.muestrate:
            self.dlg.show()
        
    
    def abrirCedula(self):
        
        seleccion = sorted(set(index.row() for index in self.dlg.tablaClaves.selectedIndexes()))[0]
        self.cveCatastral = str(self.dlg.tablaClaves.item(seleccion,0).text())

        self.confirmarInicio()
        if self.tipo == 'PAD':
            self.cedulaPadron.run(self.cveCatastral)
        elif self.tipo == 'REV':

            headers = {'Content-Type': 'application/json', 'Authorization' : self.pluginM.UTI.obtenerToken()}
            respuesta = requests.get(self.pluginM.CFG.urlObtenerIdPredioEc + self.cveCatastral, headers = headers)
            if respuesta.status_code == 200:
                idPredio = respuesta.json()

            dataCond = self.consumeWSGeneral(self.CFG.urlReviCondominios + str(idPredio))

            tieneCond = dataCond != []

            self.listaCedula[self.cveCatastral] = CedulaMainWindow(cveCatas = self.cveCatastral, cond = tieneCond, CFG = self.pluginM.CFG, UTI = self.pluginM.UTI, cargandoRevision = True)
            self.listaCedula[self.cveCatastral].verificarArranque()
            

#--------------------------------------------------------------------------

    def llenarTabla(self):

        self.vaciarTablita()

        if self.tipo == 'PAD':
            tabla = 'asignacion_padron'
        elif self.tipo == 'REV':
            tabla = 'asignacion_revision'


        index = self.dlg.cmbManzana.currentIndex()
        if index > -1:
            cveManzana = self.dlg.cmbManzana.itemData(index)

            headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}

            respuesta = requests.get(self.CFG.urlCvesUsuarioMan + tabla + '/' + self.usuarioLogeado + '/' + cveManzana, headers = headers)

            if respuesta.status_code == 200:
                    
                    datos = respuesta.json()

                    for x in range(0, len(datos)):
                        dato = datos[x]
                        if self.tipo == 'PAD':
                            claveMedia = dato[-11:]
                        elif self.tipo == 'REV':
                            claveMedia = dato[-5:]
                        self.dlg.tablaClaves.insertRow(x) 

                        item = QtWidgets.QTableWidgetItem(str(dato))
                        self.dlg.tablaClaves.setItem(x, 0 , item)#self.capaActual.getFeatures().attributes()[x])
                        item = QtWidgets.QTableWidgetItem(str(claveMedia))
                        self.dlg.tablaClaves.setItem(x, 1 , item)#self.capaActual.getFeatures().attributes()[x])

            else:
                self.UTI.mostrarAlerta('ERROR AL CARGAR INTERMEDIARIO', QMessageBox().Critical, "Consulta de asignaciones")
                print(respuesta.json())

#-----------------------------------------------------------------------------------


    def vaciarTablita(self):
        
        self.dlg.tablaClaves.clearContents()
        self.dlg.tablaClaves.setRowCount(0)
            
        for row in range(0, self.dlg.tablaClaves.rowCount()):        
            self.dlg.tablaClaves.removeRow(row) 

#--------------------------------------------------------------------------------

    def llenarCombito(self):

        headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}

        if self.tipo == 'PAD':
            respuesta = requests.get(self.CFG.urlAsigPadConsultar + self.usuarioLogeado , headers = headers)
        elif self.tipo == 'REV':
            respuesta = requests.get(self.CFG.urlAsigRevConsultar + self.usuarioLogeado , headers = headers)
        self.dlg.cmbManzana.clear()

        if respuesta.status_code == 200:
                
                datos = respuesta.json()

                if len(datos) > 0:
                    listaManzanas = []
                    for dato in datos:
                        envioManzana = dato['cveCatastral'][0:20]
                        cveManzana = envioManzana[-6:]
                        
                        if not cveManzana in listaManzanas:
                            listaManzanas.append(cveManzana)
                            self.dlg.cmbManzana.addItem(cveManzana, envioManzana)
                    self.muestrate = True
                else:
                    self.muestrate = False
                    if self.tipo == 'PAD':
                        self.UTI.mostrarAlerta('No se tienen pendientes de padron', QMessageBox().Information, "Consulta de asignaciones")
                    elif self.tipo == 'REV':
                        self.UTI.mostrarAlerta('No se tienen pendientes de revision', QMessageBox().Information, "Consulta de asignaciones")

        else:
            self.UTI.mostrarAlerta('ERROR AL CARGAR MANZANAS ASIGNADAS', QMessageBox().Critical, "Consulta de asignaciones")
            print(respuesta.json())

#----------------------------------------------------------------------------------------------------------------------

    def confirmarInicio(self):
        if self.tipo == 'PAD':
            tabla = 'padron'
        elif self.tipo == 'REV':
            tabla = 'revision'

        headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}
        respuesta = requests.post(self.CFG.urlConfirmarInicioR + self.cveCatastral + '/' + self.usuarioLogeado + '/' + tabla, headers = headers)

        if respuesta.status_code == 200:
                
                print('ACTUALIZADA LA FECCHA')
        else:
            self.UTI.mostrarAlerta('Error al actualizar fecha de inicio', QMessageBox().Critical, "Consulta de asignaciones")
            print(respuesta.json())

    def consumeWSGeneral(self, url_cons = ""):

        url = url_cons
        data = ""

        try:
            headers = {'Content-Type': 'application/json', 'Authorization' : self.pluginM.UTI.obtenerToken()}
            #headers['Authorization'] = self.pluginM.UTI.obtenerToken()
            response = requests.get(url, headers = headers)
        except requests.exceptions.RequestException as e:
            self.UTI.mostrarAlerta('Error de servidor ws general expl', QMessageBox().Critical, "Consulta de asignaciones")
            #self.createAlert("Error de servidor, 'consumeWSGeneral()' '" + str(e) + "'", QMessageBox().Critical, "Error de servidor")
            return

        if response.status_code == 200:
            data = response.content
        else:
            self.UTI.mostrarAlerta('Error de servidor ws general not 200', QMessageBox().Critical, "Consulta de asignaciones")
            #self.createAlert('Error en peticion "consumeWSGeneral()":\n' + response.text, QMessageBox().Critical, "Error de servidor")
            return

        return json.loads(data)