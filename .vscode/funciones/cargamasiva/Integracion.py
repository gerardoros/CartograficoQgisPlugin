# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Integracion
                                 A QGIS plugin
 Integracion
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-06-14
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Integracion
        email                : Integracion
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .Integracion_dialog import IntegracionDialog
import os.path
import qgis
from qgis.utils import iface
from qgis.core import *
from PyQt5.QtCore import QFileInfo, QSettings, QCoreApplication
from PyQt5.QtWidgets import QAction, QMessageBox, QFileDialog
from PyQt5.QtGui import *
from PyQt5 import QtGui
import json, requests, os
import sys

class Integracion:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Integracion_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Create the dialog (after translation) and keep reference
        self.dlg = IntegracionDialog(parent = iface.mainWindow())

        self.dlg.btnCargar.clicked.connect(self.abrirCarga)
        self.dlg.btnProcesar.clicked.connect(self.corregirLineas)
        #self.dlg.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
        QgsProject.instance().layerWasAdded.connect(self.detectarCargas)
        QgsProject.instance().layerWillBeRemoved.connect(self.detectarEliminacion)
        self.procesoCompletado = False
        self.esperandoCarga = False
        self.capaLineas = None
        self.capaPuntos = None

        self.dlg.btnProcesar.setEnabled(False)
        # Declare instance attributes
        self.todoEnOrden = False
        self.actions = []
        self.menu = self.tr(u'&Integracion')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'Integracion')
        self.toolbar.setObjectName(u'Integracion')
        self.tablas = {'manzana': 'e_manzana', 'predios.geom': 'e_predio', 'construcciones': 'e_construccion',  'horizontales.geom':'e_condominio_horizontal', 'verticales':'e_condominio_vertical', 'cves_verticales':'e_condominio_vert_clave'}


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Integracion', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/Integracion/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Integracion'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar


    def run(self):
        """Run method that performs all the real work"""
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        
        self.integrado = True
        QSettings().setValue('integrando', 'True')
        
        # See if OK was pressed
        result = self.dlg.exec_()
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

######################################################################################################

    def detectarCargas(self, layer):
        
        #for cadaUna in layer:

        if layer.name() == 'Correciones':
            return
        if self.esperandoCarga:
            self.dlg.areaInfo.setText('')
            self.actualizarStatus('Cargando capas...')
            if layer.wkbType() == 1:
                self.capaPuntos = layer
                self.dlg.fldPuntos.setText(self.capaPuntos.name())
                
            elif layer.wkbType() == 2:
                self.capaLineas = layer
                self.dlg.fldLineas.setText(self.capaLineas.name())
                

            self.zoomCapa(layer)

######################################################################################################

    def detectarEliminacion(self, layerId):
        
        if self.capaLineas != None:
            if layerId == self.capaLineas.id():
                self.capaLineas = None
                self.dlg.fldLineas.setText('')
        if self.capaPuntos != None:
            if layerId == self.capaPuntos.id():
                self.capaPuntos = None
                self.dlg.fldPuntos.setText('')
            


#########################################################################################################

    def actualizarStatus(self, texto):
        self.dlg.areaInfo.append(texto)

#######################################################################################################

    def integrar(self):
        if self.procesoCompletado:
            self.dlg.areaInfo.setText('')
            self.guardarNormales()
            if self.guardadoBien:
                self.guardarAreasIns()
        else:
            self.UTI.mostrarAlerta('Primero debes procesar las capas de carga', QMessageBox().Critical, 'Error de integracion')

#######################################################################################################

    def guardarNormales(self):
        print('entro al guardar')
        self.guardadoBien = False
        
        root = QgsProject.instance().layerTreeRoot()

        group = root.findGroup('ERRORES DE TOPOLOGIA')
        if not group is None:
            for child in group.children():
                dump = child.dump()
                id = dump.split("=")[-1].strip()
                QgsProject.instance().removeMapLayer(id)
            root.removeChildNode(group)

        for layer in iface.mapCanvas().layers():
            layer.triggerRepaint()

        if QSettings().value('posibleGuardar') == 'True':
            print('fue posible guardar masivo')
            self.listaAGuardar = []

            self.agregarALista('manzana')
            self.agregarALista('predios.geom')
            self.agregarALista('construcciones')
            self.agregarALista('horizontales.geom')
            self.agregarALista('verticales')
            self.agregarALista('cves_verticales')
       
            #Formato para solicitar la peticion
            jsonParaGuardarAtributos = json.dumps(self.listaAGuardar)

            print (jsonParaGuardarAtributos)
            
            url='http://192.168.0.40:8080/featureswkn/api/manzana/'
            payload = jsonParaGuardarAtributos
            headers = {'Content-Type': 'application/json', 'Authorization' : self.obtenerToken()}
            try:
                response = requests.post(url, headers = headers, data = payload)
            
            except requests.exceptions.RequestException:
                self.UTI.mostrarAlerta("No se ha podido conectar al servidor v1", QMessageBox.Critical, "Guardar Cambios v1")#Error en la peticion de consulta
            
            print(response.json())
            print(response.status_code)
            if response.status_code == 200:
                self.UTI.mostrarAlerta("Cambios guardados con exito", QMessageBox.Information, "Guardar Cambios")
                self.dlg.fldLineas.setText('')
                self.dlg.fldPuntos.setText('')
                self.actualizarStatus('Se han guardado ' + str(self.cuentaManzanas) + " manzanas y " + str(self.cuentaPredios) + ' predios')
                self.procesoCompletado = False
                self.guardadoBien = True
                self.todoEnOrden = False
                
                QSettings().value('integrando') == 'False'

            elif response.status_code == 202:
                self.UTI.mostrarAlerta('Se han detectado errores de topologia', QMessageBox().Critical, 'Errores de topologia')
                root.insertGroup(0, 'ERRORES DE TOPOLOGIA')

                capa = QgsVectorLayer('Point?crs=epsg:' + str(QSettings().value('srid')) +'&field=mensaje:string(80)', 'ERRORES PUNTO', 'memory')

                QgsProject.instance().addMapLayers([capa], False)

                props = capa.renderer().symbol().symbolLayer(0).properties()
                props['color'] = '#FF0000'
                capa.renderer().setSymbol(QgsMarkerSymbol.createSimple(props))

                QgsProject.instance().addMapLayer(capa, False)
                grupoErrores = root.findGroup('ERRORES DE TOPOLOGIA')
                capaError = QgsLayerTreeLayer(capa)
                capa.startEditing()

                settings = QgsPalLayerSettings()
                settings.fieldName = 'mensaje'
                settings.enabled = True
                
                settings.centroidWhole = True

                textFormat = QgsTextFormat()
                textFormat.setColor(QColor(255,153,0))
                textFormat.setSize(8)
                textFormat.setNamedStyle('Bold')

                settings.setFormat(textFormat)

                labeling = QgsVectorLayerSimpleLabeling(settings)

                capa.setLabeling(labeling)
                capa.setLabelsEnabled(True)
                capa.triggerRepaint()



                puntosMalos = response.json()

                for malo in puntosMalos:
                    
                    #print(malo)
                    #print(type(malo))
                    geom = QgsGeometry.fromWkt(malo["wkt"])
                    feat = QgsFeature()
                    feat.setGeometry(geom)
                    feat.setAttributes([malo['mensaje']])
                    capa.dataProvider().addFeatures([feat])
                    capa.updateFeature(feat)

                capa.triggerRepaint()
                capa.commitChanges()
                grupoErrores.insertChildNode(0, capaError)

            else:
                self.UTI.mostrarAlerta("No se ha podido conectar al servidor v2\n" + str(response.json()[0]['mensaje']), QMessageBox.Critical, "Guardar Cambios v2")
                #Error al guardar dato
            
        else:
            self.UTI.mostrarAlerta("Se debe validar la topologia antes de guardar", QMessageBox.Critical, "Guardar Cambios v4")
        

        QSettings().setValue('posibleGuardar', 'False')

######################################################################################################################

    def agregarALista(self, idCapa):

        capa = QgsProject.instance().mapLayer(self.obtenerIdCapa(idCapa))

        for feat in capa.getFeatures():
            campos = {}
            if idCapa == 'cves_verticales':
                campos['wkt'] = feat.geometry().asWkt()
            else:
                campos['wkt'] = feat.geometry().asWkt()
            campos['srid'] = QSettings().value('srid')
            campos['tabla'] = self.tablas[capa.name()]
            atributos = {}
            nombresAtrbutos = capa.fields()   

            nombres = [campo.name() for campo in nombresAtrbutos]

            for x in range(0, len(nombres)):
                atributo = feat.attributes()[x]
                if str(feat.attributes()[x]) == "NULL":
                    atributo = None
                atributos[str(nombres[x])] = atributo

                if idCapa == 'predios.geom':
                    punto = self.exteriorPredio(feat.geometry())
                    if punto != None:
                        
                        atributos['numExt'] = punto['numExt']
                        atributos['geom_num'] = punto.geometry().asWkt()

                elif idCapa == 'horizontales.geom':
                    punto = self.exteriorCondom(feat.geometry())
                    if punto != None:
                        atributos['num_ofi'] = punto['num_ofi']
                        atributos['geom_num'] = punto.geometry().asWkt()

                campos['nuevo'] = True
                campos['eliminado'] = False

            campos['attr'] = atributos
            self.listaAGuardar.append(campos)


#######################################################################################################################

    def exteriorPredio(self, predio):

        puntos = QgsProject.instance().mapLayer(self.obtenerIdCapa('predios.num')).getFeatures()

        for punto in puntos:
            if punto.geometry().intersects(predio):
                return punto

    def exteriorCondom(self, condominio):

        puntos = QgsProject.instance().mapLayer(self.obtenerIdCapa('horizontales.num')).getFeatures()

        for punto in puntos:
            if punto.geometry().intersects(condominio):
                return punto

########################################################################################################################

    def guardarAreasIns(self):
        
        idCapa = str(QSettings().value('xAreasInscritas'))
        capa = QgsProject.instance().mapLayer(idCapa)
        listaAGuardar = []

        for feat in capa.getFeatures():

            campos = {}
            campos['accion'] = 'new'
            campos['geomWKT'] = feat.geometry().asWkt()
            campos['srid'] = str(QSettings().value('srid'))
            campos['nombre'] = 'e_area_inscrita'
            atributos = {}
            nombresAtrbutos = capa.fields()   

            nombres = []

            nombres = [campo.name() for campo in nombresAtrbutos]

            for x in range(0, len(nombres)):
                
                atributo = feat.attributes()[x]
                
                if str(feat.attributes()[x]) == "NULL":
                    atributo = None
                atributos[str(nombres[x])] = atributo
            
            campos['propiedades'] = atributos

            listaAGuardar.append(campos)

        jsonParaGuardarAtributos = json.dumps(listaAGuardar)

        print(jsonParaGuardarAtributos)
        payload = jsonParaGuardarAtributos
        headers = {'Content-Type': 'application/json', 'Authorization' : self.obtenerToken()}
        print(payload)
        try:
            response = requests.post('http://192.168.0.40:6543/api/etables/', headers = headers, data = payload)
        
        except requests.exceptions.RequestException:
            #self.UTI.mostrarAlerta("No se ha podido conectar al servidor v1", QMessageBox.Critical, "Guardar Cambios v1")#Error en la peticion de consulta
            print('EXCEPETION TROPA', response)

        print(response.status_code)
        if response.status_code == 200:

            print('CODIGO 200 AREAS INSCRITAS, GUARADO CON EXITO')

        

        else:
            print('NEGATIVO TROPA', response.json())
        
###########################################################################################

    def obtenerToken(self):
        url= 'http://127.0.0.1:8080/auth/login'
        payload = {"username" : "user", "password" : "user"}
        payload = json.dumps(payload)
        headers = {'Content-Type': 'application/json'}

        response = requests.post(url, headers = headers, data = payload)
        if response.status_code == 200:
            #print('habemus token')
            data = response.content
        else:
            print(response)
            self.UTI.mostrarAlerta('No se ha conseguido token del plugin de integracion', QMessageBox().Critical, 'Autenticacion')
            return

        return 'bearer ' + json.loads(data)['access_token']


#############################################################################################################

    def zoomCapa(self, capa):
        listaFeats = list(capa.getFeatures())
        geometria = QgsGeometry()

        rango = len(listaFeats)

        if rango == 0:
            return

        geometria = listaFeats[0].geometry()

        for i in range(0, rango):
            geometria = geometria.combine(listaFeats[i].geometry())

        bbox = geometria.boundingBox()
        iface.mapCanvas().setExtent(bbox)
        iface.mapCanvas().refresh()
        if self.capaPuntos != None and self.capaLineas != None:
            self.actualizarStatus('Capas cargadas')
########################################################################################################

    def abrirCarga(self):
        #self.archivo = QtGui.QFileDialog.getOpenFileName(self, 'Abir Archivo')
        
        options = QFileDialog.Options()
        #options |= QFileDialog.DontUseNativeDialog
        fileName, _ = QFileDialog.getOpenFileName(self.dlg,"QFileDialog.getOpenFileName()", "","DGN Files (*.dgn)", options=options)

        if fileName:
            self.archivo = fileName
            self.esperandoCarga = True
            iface.addVectorLayer(self.archivo, "NUEVACAPA", "ogr")



        iface.mapCanvas().refreshAllLayers()
        if self.capaLineas != None and self.capaPuntos != None:
            self.dlg.btnProcesar.setEnabled(True)

###############################################################################################################

    
    def vaciarCapa(self, nombreCapa):

        if nombreCapa != 'Correciones' and nombreCapa != 'areas_inscritas':
            capa = QgsProject.instance().mapLayer(self.obtenerIdCapa(nombreCapa))
        else:
            capa = QgsProject.instance().mapLayersByName(nombreCapa)[0]
        capa.startEditing()

        for f in capa.getFeatures():
            capa.deleteFeature(f.id())
        
        capa.commitChanges()

#-------------------------------------------------------

    def obtenerVertices(self, geom):
        n  = 0
        ver = geom.vertexAt(0)
        vertices=[]

        while(ver != QgsPoint(0,0)):
            n +=1
            vertices.append(ver)
            ver=geom.vertexAt(n)

        return vertices

#------------------------------------------------------------


#--------------------------------------------------------------------------

    def obtenerPuntoCercanoConjunto(self, entrada, lista):
        
        geomEntrada = QgsGeometry(QgsGeometry.fromPointXY(QgsPointXY( entrada.x(), entrada.y())))
        
        for conjunto in lista:
            for punto in conjunto:
                geomPunto = QgsGeometry(QgsGeometry.fromPointXY(QgsPointXY( punto.x(), punto.y())))
            
                tamanoBuff = 0.2

                if geomEntrada.distance(geomPunto) > (tamanoBuff + 0.1):
                    continue

                if entrada.x() == punto.x() and entrada.y() == punto.y():
                    continue
                

                bufferEntrada = geomEntrada.buffer(tamanoBuff,16)
                
                if bufferEntrada.intersects(geomPunto):

                    return punto

        return None

#---------------------------------------------------------------------

#--------------------------------------------------------------------------

    def checarExistenciaCercana(self, entrada, lista):

        for punto in lista:
            if entrada.x() == punto.x() and entrada.y() == punto.y():
                lista.remove(punto)
        
        return lista
            
#-----------------------------------------------------------------------

    def renombrarVolumenes(self):
        self.actualizarStatus('Renombrando volumenes...')
        capaPredios = QgsProject.instance().mapLayersByName('predios.geom')[0]
        capaConst = QgsProject.instance().mapLayersByName('construcciones')[0]
        
        capaConst.startEditing()
        for predio in capaPredios.getFeatures():
            ultimoVolumen = 0
            listaSinVol = []
            listaConVol = []
            for const in capaConst.getFeatures():
                numVol = const['nom_volumen']
                if predio.geometry().intersects(const.geometry().buffer(-0.0000001,1)) or (predio.geometry().intersection(const.geometry().buffer(0.0000001,1)).area() >0.0000000001 and self.contarIntegraciones(const.geometry().buffer(-0.0000001,1), 'predios.geom') == 0):
                    if numVol != '' and numVol != None:
                        numVol = int(numVol[1:len(numVol)])

                        if int(numVol) > ultimoVolumen:
                            ultimoVolumen = numVol
                    else:
                        listaSinVol.append(const)

            for const in listaSinVol:
                ultimoVolumen += 1
                const['nom_volumen'] = 'V' + str(ultimoVolumen)
                capaConst.updateFeature(const)

        capaConst.triggerRepaint()
        capaConst.commitChanges()
        self.actualizarStatus('----> PROCESO COMPLETADO <----')
#---------------------------------------------------------

#--------------------------------------------------------------

    def corregirLineas(self):
        
        if self.capaLineas == None or self.capaPuntos == None:
            self.UTI.mostrarAlerta('No se han cargado las lineas y etiquetas necesarias para proceder', QMessageBox().Critical, 'Error de carga')
            return

        self.esperandoCarga = False

        print('CORRECION: INICIO')
        self.actualizarStatus('Obteniendo cuadrantes...')
        #nombreParam = self.dlg.cmbLineas.text()
        capaParam = self.capaLineas

        capaCorreciones = QgsProject.instance().mapLayersByName('Correciones')
        capaAreasInscritas = QgsProject.instance().mapLayersByName('areas_inscritas')[0]

        if len(capaCorreciones) == 0:
            Azu = QgsVectorLayer('LineString?crs=epsg:32614&field=clave:string(15)&index=yes', 'Correciones', 'memory')
            QgsProject.instance().addMapLayer(Azu, True)
            capaCorreciones = QgsProject.instance().mapLayersByName('Correciones')[0]
        else:
            capaCorreciones = capaCorreciones[0]
        
        self.vaciarCapa('Correciones')


        capaPuntosBen = self.capaPuntos

        capaManzana = QgsProject.instance().mapLayer(self.obtenerIdCapa('manzana'))
        capaPredios = QgsProject.instance().mapLayer(self.obtenerIdCapa('predios.geom'))
        capaConst = QgsProject.instance().mapLayer(self.obtenerIdCapa('construcciones'))
        capaHorizontalesG = QgsProject.instance().mapLayer(self.obtenerIdCapa('horizontales.geom'))
        capaVerticalesG = QgsProject.instance().mapLayer(self.obtenerIdCapa('verticales'))

        capaHorizontalesNum = QgsProject.instance().mapLayer(self.obtenerIdCapa('horizontales.num'))
        capaVerticalesNum = QgsProject.instance().mapLayer(self.obtenerIdCapa('cves_verticales'))
        capaPrediosNum = QgsProject.instance().mapLayer(self.obtenerIdCapa('predios.num'))

        diccCapas = {}
        diccCapas[7] = capaPrediosNum
        diccCapas[13] = capaVerticalesNum
        diccCapas[11] = capaHorizontalesNum

        self.vaciarCapa('manzana')
        self.vaciarCapa('predios.geom')
        self.vaciarCapa('construcciones')
        self.vaciarCapa('horizontales.geom')
        self.vaciarCapa('predios.num')
        self.vaciarCapa('verticales')
        self.vaciarCapa('cves_verticales')
        self.vaciarCapa('horizontales.num')
        self.vaciarCapa('areas_inscritas')

        self.pintarBoundingBox()
        tarifaX = self.boundBox.width() / 2
        tarifaY = self.boundBox.width() / 2

        #minX = self.boundBox.xMinimum()
        x1 = self.boundBox.xMinimum() + tarifaX
        #x2 = self.boundBox.xMinimum() + (2*tarifaX)
        x2 = self.boundBox.xMaximum()

        y1 = self.boundBox.yMinimum() + tarifaY
        #y2 = self.boundBox.yMinimum() + (2*tarifaY)
        y2 = self.boundBox.yMaximum()

        todasLineas = list(capaParam.getFeatures())

        
        print('CORRECION: CAPAS')
        todoVertices = []
        print('CORRECION: OBTENIENDO VERTICES')
        
        cuadrantes = [[],[],[],[],[],[],[],[],[]]
        relacionVerticeCuad = {}
        datosLinea = []
        for linea in todasLineas: #Obtenemos todas las lineas de la capa parametros, las lineas estan sin ensamblar, todas feas
            
            vertices = self.obtenerVertices(linea.geometry())
            todoVertices.append([])
            #datosLinea.append([])
            #print(linea.attributes())W
            datosLinea.append(linea.attributes()[1])
            for vertice in vertices:
                
                todoVertices[len(todoVertices)-1].append(vertice)
                
                if vertice.x() <= x1:
                    if vertice.y() <= y1:
                        cuadrantes[0].append(vertice)
                        relacionVerticeCuad[str(vertice.x())+str(vertice.y())] = 0
                    else:
                        cuadrantes[2].append(vertice)
                        relacionVerticeCuad[str(vertice.x())+str(vertice.y())] = 2
                else:
                    if vertice.y() <= y1:
                        cuadrantes[1].append(vertice)
                        relacionVerticeCuad[str(vertice.x())+str(vertice.y())] = 1
                    else:
                        cuadrantes[4].append(vertice)
                        relacionVerticeCuad[str(vertice.x())+str(vertice.y())] = 4
                
        self.actualizarStatus('Corrigiendo geometrias...')
        listaPuntosCercanos = []
        listaParam = []
        print('CORRECION: ITERANDO VERTICES Y OBTENIENDO PUNTOS CERCANOS')
        indiceConjunto = 0
        
        for conjunto in todoVertices: #Obtenemos todos los conjuntos de vertices (cada iteracion de aqui es una linea)
            listaPuntos = []
            listaParam.append([])
            for vertice in conjunto: #Obtenemos cada vertice de cada linea

                indice = relacionVerticeCuad[str(vertice.x())+str(vertice.y())]
                puntoCercano = self.obtenerPuntoCercanoConjunto(vertice, [cuadrantes[indice]]) #Checamos si tiene un punto cercando al cual pegarse
                #En caso de que el vertice ya haya sido punto cercano entonces se pasa tal cual
                if puntoCercano == None or self.checarContenido(vertice, listaPuntosCercanos): #o tambien si no tiene un punto cercanp
                    listaPuntos.append(vertice)
                    continue
                else: #En caso contrario, seguramente el vertice tiene un punto cercano al cual pegarse
                    listaPuntos.append(puntoCercano)
                    listaPuntosCercanos.append(puntoCercano)
                    lineaTemp = QgsGeometry( QgsGeometry.fromPolyline(listaPuntos))
                    self.reemplazarVertice(vertice, puntoCercano, [cuadrantes[indice]])
            
            
            nuevaLinea = QgsGeometry( QgsGeometry.fromPolyline(listaPuntos))

            self.agregarLineaCapaDatos(nuevaLinea, capaCorreciones, [datosLinea[indiceConjunto]])
            indiceConjunto += 1
            
        self.actualizarStatus('Poligonizando geometrias...')
        todasCorreciones = list(capaCorreciones.getFeatures())
        lineasManzana = []
        lineasPredios = []
        lineasConst = []
        lineasCondH = []
        lineasCondV = []
        lineasAreaI = []
        capaCorreciones.startEditing()
        for x in range(0, len(todasCorreciones)):
            linea = todasCorreciones[x]
            
            if datosLinea[x] == 1:
                lineasManzana.append(linea.geometry())
                lineasPredios.append(linea.geometry())
                lineasConst.append(linea.geometry())
            elif datosLinea[x] == 3:
                lineasPredios.append(linea.geometry())
                lineasConst.append(linea.geometry())
            elif datosLinea[x] == 5 or datosLinea[x] == 8:
                lineasConst.append(linea.geometry())
            elif datosLinea[x] == 10:
                lineasCondH.append(linea.geometry())
            elif datosLinea[x] == 12:
                lineasCondV.append(linea.geometry())
            elif datosLinea[x] == 17:
                lineasAreaI.append(linea.geometry())

        #print(lineasManzana)
        print('CORRECION: POLIGONIZANDO')
        #-----------------------------------POLIGONIZA MANZNA ------------------------------ #
        polys = QgsGeometry.polygonize(lineasManzana)
        
        capaManzana.startEditing()
        for sub in polys.asMultiPolygon():

            feat = QgsFeature()
            wkt = QgsGeometry.fromPolygonXY(sub).asWkt()
            geom = QgsGeometry.fromWkt(wkt)
            feat.setGeometry( geom )

            capaManzana.dataProvider().addFeatures([feat])
        
        iface.mapCanvas().refresh()
        capaManzana.triggerRepaint()
        capaManzana.commitChanges()
        
         #-----------------------------------POLIGONIZA PREDIOS ------------------------------ #
        polys = QgsGeometry.polygonize(lineasPredios)
        
        capaPredios.startEditing()
        for sub in polys.asMultiPolygon():

            feat = QgsFeature()
            wkt = QgsGeometry.fromPolygonXY(sub).asWkt()
            geom = QgsGeometry.fromWkt(wkt)
            feat.setGeometry( geom )

            capaPredios.dataProvider().addFeatures([feat])
        
        iface.mapCanvas().refresh()
        capaPredios.triggerRepaint()
        capaPredios.commitChanges()

        #-----------------------------------POLIGONIZA CONSTRUCCIONES ------------------------------ #
        polys = QgsGeometry.polygonize(lineasConst)
        
        capaConst.startEditing()
        for sub in polys.asMultiPolygon():

            feat = QgsFeature()
            wkt = QgsGeometry.fromPolygonXY(sub).asWkt()
            geom = QgsGeometry.fromWkt(wkt)
            feat.setGeometry( geom )

            bandera = False

            for punto in capaPuntosBen.getFeatures():
                geomPunto = punto.geometry()

                if geomPunto.intersects(geom):
                    if punto['Level'] == 6 or punto['Level'] == 9 or punto['Level'] == 15 or punto['Level'] == 20:
                        bandera = True
                        break
            
            if bandera:
                capaConst.dataProvider().addFeatures([feat])
        
        iface.mapCanvas().refresh()
        capaConst.triggerRepaint()
        capaConst.commitChanges()
        
        #-----------------------------------POLIGONIZA CONDOMINIOS HORI------------------------------ #
        polys = QgsGeometry.polygonize(lineasCondH)
        
        capaHorizontalesG.startEditing()
        for sub in polys.asMultiPolygon():

            feat = QgsFeature()
            wkt = QgsGeometry.fromPolygonXY(sub).asWkt()
            geom = QgsGeometry.fromWkt(wkt)
            feat.setGeometry( geom )

            bandera = False

            for punto in capaPuntosBen.getFeatures():
                geomPunto = punto.geometry()

                if geomPunto.intersects(geom):
                    if punto['Level'] == 11:
                        bandera = True
                        break
            
            if bandera:
                capaHorizontalesG.dataProvider().addFeatures([feat])
        
        iface.mapCanvas().refresh()
        capaHorizontalesG.triggerRepaint()
        capaHorizontalesG.commitChanges()

        #-----------------------------------POLIGONIZA CONDOMINIOS VERT------------------------------ #
        polys = QgsGeometry.polygonize(lineasCondV)
        
        capaVerticalesG.startEditing()
        for sub in polys.asMultiPolygon():

            feat = QgsFeature()
            wkt = QgsGeometry.fromPolygonXY(sub).asWkt()
            geom = QgsGeometry.fromWkt(wkt)
            feat.setGeometry( geom )

            bandera = False

            for punto in capaPuntosBen.getFeatures():
                geomPunto = punto.geometry()

                if geomPunto.intersects(geom):
                    if punto['Level'] == 13:
                        bandera = True
                        break
            
            if bandera:
                capaVerticalesG.dataProvider().addFeatures([feat])
        
        iface.mapCanvas().refresh()
        capaVerticalesG.triggerRepaint()
        capaVerticalesG.commitChanges()

        #-----------------------------------POLIGONIZA AREAS INSCRITAS------------------------------ #
        polys = QgsGeometry.polygonize(lineasAreaI)
        
        capaAreasInscritas.startEditing()
        for sub in polys.asMultiPolygon():

            feat = QgsFeature()
            wkt = QgsGeometry.fromPolygonXY(sub).asWkt()
            geom = QgsGeometry.fromWkt(wkt)
            feat.setGeometry( geom )

            bandera = False

            for punto in capaPuntosBen.getFeatures():
                geomPunto = punto.geometry()

                if geomPunto.intersects(geom):
                    if punto['Level'] == 16:
                        bandera = True
                        break
            if bandera:
                capaAreasInscritas.dataProvider().addFeatures([feat])
        
        iface.mapCanvas().refresh()
        capaAreasInscritas.triggerRepaint()
        capaAreasInscritas.commitChanges()

        #-----------------------------------DIBUJANDO PUNTOS------------------------------ #
        
        for punto in capaPuntosBen.getFeatures():
            geomPunto = punto.geometry()

            level = punto['Level']

            if level != 11 and level != 13 and level != 7:
                continue

            capa = diccCapas[level]
            
            self.agregarWktCapa(geomPunto.asWkt(), capa)


        print('CORRECION: COMPLETA')
        self.asignarDatos()
        self.procesoCompletado = True
        print('ASINACION DE INGORMACION COMPLETA')

#---------------------------------------------------------------------------------------------

    def asignarDatos(self):
        
        capaManzana = QgsProject.instance().mapLayer(self.obtenerIdCapa('manzana'))
        capaPredios = QgsProject.instance().mapLayer(self.obtenerIdCapa('predios.geom'))
        capaConst = QgsProject.instance().mapLayer(self.obtenerIdCapa('construcciones'))
        capaHorizontalesG = QgsProject.instance().mapLayer(self.obtenerIdCapa('horizontales.geom'))
        capaVerticalesG = QgsProject.instance().mapLayer(self.obtenerIdCapa('verticales'))
        capaHorizontalesNum = QgsProject.instance().mapLayer(self.obtenerIdCapa('horizontales.num'))
        capaVerticalesNum = QgsProject.instance().mapLayer(self.obtenerIdCapa('cves_verticales'))
        capaPrediosNum = QgsProject.instance().mapLayer(self.obtenerIdCapa('predios.num'))
        
        capaPuntos = self.capaPuntos

        capaAreasInscritas = QgsProject.instance().mapLayersByName('areas_inscritas')[0]
        self.actualizarStatus('Asignando datos...')
        #ASIGNAR DATOS A MANZANA
        capaManzana.startEditing()
        for manzana in capaManzana.getFeatures():
            geomManzana = manzana.geometry()
            
            for punto in capaPuntos.getFeatures():
                if geomManzana.intersects(punto.geometry()):
                    level = punto['Level']
                    texto = punto['Text']

                    if level == 2:
                        manzana['clave'] = texto
                        
            capaManzana.updateFeature(manzana)
        capaManzana.triggerRepaint()
        capaManzana.commitChanges()

        #ASIGNAR DATOS A CONSTRUCCION
        capaConst.startEditing()
        for const in capaConst.getFeatures():
            geomConst = const.geometry().buffer(-0.0000001,1)
            for punto in capaPuntos.getFeatures():
                if geomConst.intersects(punto.geometry()):
                    level = punto['Level']
                    texto = punto['Text']

                    if level == 6:
                        const['num_niveles'] = int(texto)
                        
                    elif level == 9:
                        const['cve_const_esp'] = texto
                    elif level == 15 or level == 19:
                        const['nom_volumen'] = texto.replace('U','V')

            capaConst.updateFeature(const)
        
        capaConst.triggerRepaint()
        capaConst.commitChanges()

        #ASIGNAR SUPERFICIES A PREDIOS
        capaPredios.startEditing()
        for predio in capaPredios.getFeatures():
            area = predio.geometry().area()
            predio['sup_terr'] = area
            listaPrimera = []
            listaFinal = []
            for construccion in capaConst.getFeatures():
                geomConstru = construccion.geometry()
                
                if geomConstru.buffer(-0.0000001, 1).intersects(predio.geometry()):#Sacamos las construcciones dentro del predio fusionado
                    listaPrimera.append(construccion)
                else:
                    if self.contarIntegraciones( geomConstru.buffer(-0.0000001, 1), 'predios.geom' ) == 0: #Obtenemos los aleros del predio fusionado
                        if geomConstru.buffer(0.0000001, 1).intersection(predio.geometry()).area() > 0.000000001:
                            listaPrimera.append(construccion)

            for construccion in listaPrimera:
                geomConstru = construccion.geometry()
                seIncluye = True
                for condominio in capaHorizontalesG.getFeatures():
                    geomHori = condominio.geometry() 
                    if geomConstru.buffer(-0.0000001, 1).intersects(geomHori):
                        seIncluye = False
                        break
                    
                if seIncluye:
                    listaFinal.append(construccion)

            supConst = 0 #Renombramos ls volumenes
            niveles = 0
            for construccion in listaFinal:
                geomConstru = construccion.geometry()
                try:
                    niveles = int(str(construccion['num_niveles']))
                except:
                    niveles = 1

                if niveles <= 0:
                    niveles = 1
                supConst += (geomConstru.area() * niveles)
            
            predio['sup_contruccion'] = supConst


            for punto in capaPuntos.getFeatures():
                if predio.geometry().intersects(punto.geometry()):
                    level = punto['Level']
                    texto = punto['Text']

                    if level == 4:
                        predio['clave'] = texto
                    elif level == 7:
                        predio['num_ext'] = texto

            capaPredios.updateFeature(predio)
        capaPredios.triggerRepaint()
        capaPredios.commitChanges()
        
        #ASIGNAR DATOS A CONDOMINIOS HORIZONTALES
        capaHorizontalesG.startEditing()
        for cond in capaHorizontalesG.getFeatures():
            geom = cond.geometry()
            
            for punto in capaPuntos.getFeatures():
                if geom.intersects(punto.geometry()):
                    level = punto['Level']
                    texto = punto['Text']

                    if level == 11:
                        cond['clave'] = texto
                    elif level == 14:
                        cond['num_ofi'] = texto
                       
            capaHorizontalesG.updateFeature(cond)
        capaHorizontalesG.triggerRepaint()
        capaHorizontalesG.commitChanges() 

        #ASIGNAR DATOS A CONDOMINIOS VERTICALES
        capaVerticalesG.startEditing()
        for cond in capaVerticalesG.getFeatures():
            geom = cond.geometry()
            
            for punto in capaPuntos.getFeatures():
                if geom.intersects(punto.geometry()):
                    level = punto['Level']
                    texto = punto['Text']

                    if level == 13:
                        cond['clave'] = texto
                        
            capaVerticalesG.updateFeature(cond)
        capaVerticalesG.triggerRepaint()
        capaVerticalesG.commitChanges() 


        #ASIGNAR DATOS A PUNTOS DE PREDIOS
        capaPrediosNum.startEditing()
        for entrada in capaPrediosNum.getFeatures():
            geom = entrada.geometry().buffer(0.0000001,1)
            
            for punto in capaPuntos.getFeatures():
                if geom.intersects(punto.geometry()):
                    level = punto['Level']
                    texto = punto['Text']

                    if level == 7:
                        entrada['numExt'] = texto
                        
            capaPrediosNum.updateFeature(entrada)
        capaPrediosNum.triggerRepaint()
        capaPrediosNum.commitChanges() 

        #ASIGNAR DATOS A PUNTOS DE HORIZONTALES
        capaHorizontalesNum.startEditing()
        for entrada in capaHorizontalesNum.getFeatures():
            geom = entrada.geometry().buffer(0.0000001,1)
            
            for punto in capaPuntos.getFeatures():
                if geom.intersects(punto.geometry()):
                    level = punto['Level']
                    texto = punto['Text']

                    if level == 11:
                        entrada['num_ofi'] = texto
                        
            capaHorizontalesNum.updateFeature(entrada)
        capaHorizontalesNum.triggerRepaint()
        capaHorizontalesNum.commitChanges() 

        #ASIGNAR DATOS A PUNTOS DE VERTICALES
        capaVerticalesNum.startEditing()
        for entrada in capaVerticalesNum.getFeatures():
            geom = entrada.geometry().buffer(0.0000001,1)
            
            for punto in capaPuntos.getFeatures():
                if geom.intersects(punto.geometry()):
                    level = punto['Level']
                    texto = punto['Text']

                    if level == 13:
                        entrada['clave'] = texto
                        
            capaVerticalesNum.updateFeature(entrada)
        capaVerticalesNum.triggerRepaint()
        capaVerticalesNum.commitChanges() 

        #ASIGNAR DATOS A AREAS INSCRITAS
        capaAreasInscritas.startEditing()
        for entrada in capaAreasInscritas.getFeatures():
            geom = entrada.geometry()
            
            for punto in capaPuntos.getFeatures():
                if geom.intersects(punto.geometry()):
                    level = punto['Level']
                    texto = punto['Text']

                    if level == 16:
                        entrada['valor'] = 0
                        entrada['descripcion'] = 'S/D'
                        entrada['clave'] = texto
                        
            capaAreasInscritas.updateFeature(entrada)
        capaAreasInscritas.triggerRepaint()
        capaAreasInscritas.commitChanges() 

        self.cuentaManzanas = capaManzana.featureCount()
        self.cuentaPredios = capaPredios.featureCount()

        if self.cuentaManzanas == 0:
            self.UTI.mostrarAlerta('No se han detectado manzanas, por favor, corrije el archivo de entrada', QMessageBox().Critical, 'Error de carga')
            self.todoEnOrden = False
        else:
            self.todoEnOrden = True
            
            self.actualizarStatus('Se han cargado ' + str(capaManzana.featureCount()) + ' manzanas')
            self.actualizarStatus('Se han cargado ' + str(capaPredios.featureCount()) + ' predios')
            self.renombrarVolumenes()
            self.resetearIntegracion()
            self.UTI.mostrarAlerta('Proceso completado con exito\nValida la topologia para integrar', QMessageBox().Information, 'Carga completa')

#---------------------------------------------------------------------------------------------------


#------------------------------------------------------------------------------------

    def checarContenido(self, entrada, lista):
        for punto in lista:
            if entrada.x() == punto.x() and entrada.y() == punto.y():
                return True
        return False

    def reemplazarVertice(self, entrada, nuevo, lista):
        
        for conjunto in lista:
            indiceCon = lista.index(conjunto)
            for punto in conjunto:
                if entrada.x() == punto.x() and entrada.y() == punto.y():
                    indicePun = lista[indiceCon].index(punto)
                    lista[indiceCon][indicePun] = nuevo
        return False


    def agregarPuntoCapa(self, punto, capa):
        capa.startEditing()
        feat = QgsFeature()
        puntoXY = QgsPointXY(punto.x(), punto.y())
        feat.setGeometry(QgsGeometry(QgsGeometry.fromPointXY(puntoXY)))
        capa.dataProvider().addFeatures([feat])
        capa.triggerRepaint()
        capa.commitChanges()

    def agregarLineaCapa(self, linea, capa):
        capa.startEditing()
        feat = QgsFeature()
        feat.setGeometry(linea)
        capa.dataProvider().addFeatures([feat])
        capa.triggerRepaint()
        capa.commitChanges()

    def agregarLineaCapaDatos(self, linea, capa, datos):
        capa.startEditing()
        feat = QgsFeature()
        feat.setGeometry(linea)
        capa.dataProvider().addFeatures([feat])
        
        capa.triggerRepaint()
        capa.commitChanges()

        capa.startEditing()
        
        feat.setAttributes(datos)
        
        capa.updateFeature(feat)
        capa.triggerRepaint()
        capa.commitChanges()
        
        #print(feat.attributes())

    def agregarWktCapa(self, param, capa):
        capa.startEditing()
        feat = QgsFeature()
        if 'PointZ' in param:
            param = param.replace('PointZ', 'Point').replace('0)', ')').replace(' )', ')')
        feat.setGeometry(QgsGeometry.fromWkt(param))
        capa.dataProvider().addFeatures([feat])
        capa.triggerRepaint()
        capa.commitChanges()


#---------------------------------------------------------------------------------------------

    def pintarBoundingBox(self):
        capaParam = self.capaLineas

        listaFeats = list(capaParam.getFeatures())
        geometria = QgsGeometry()

        rango = len(listaFeats)
        geometria = listaFeats[0].geometry()

        for i in range(0, rango):
            geometria = geometria.combine(listaFeats[i].geometry())

        self.boundBox = geometria.boundingBox()


    def contarIntegraciones(self, geometria, nombreCapa):
        capa = QgsProject.instance().mapLayer(self.obtenerIdCapa(nombreCapa))
        cuenta = 0
        for feat in capa.getFeatures():
            if geometria.intersects(feat.geometry()):
                cuenta += 1

        return cuenta



#--------------------------------------------------------------------------------------

    def obtenerIdCapa(self, nombreCapa):

        if nombreCapa == "manzana":
            return QSettings().value('xManzana')
        elif nombreCapa == "predios.geom":
            return QSettings().value('xPredGeom')
        elif nombreCapa == "predios.num":
            return QSettings().value('xPredNum')
        elif nombreCapa == "construcciones":
            return QSettings().value('xConst')
        elif nombreCapa == "horizontales.geom":
            return QSettings().value('xHoriGeom')
        elif nombreCapa == "horizontales.num":
            return QSettings().value('xHoriNum')
        elif nombreCapa == "verticales":
            return QSettings().value('xVert')
        elif nombreCapa == "cves_verticales":
            return QSettings().value('xCvesVert')
        elif nombreCapa == "Area de Valor":
            return QSettings().value('xAreaValor')
        elif nombreCapa == "Zona Uno":
            return QSettings().value('xZonaUno')
        elif nombreCapa == "Zona Dos":
            return QSettings().value('xZonaDos')
        elif nombreCapa == "Codigo Postal":
            return QSettings().value('xCP')
        elif nombreCapa == "Colonias":
            return QSettings().value('xColonia')
        elif nombreCapa == "Calles":
            return QSettings().value('xCalle')
        elif nombreCapa == "Sectores":
            return QSettings().value('xSector')
        elif nombreCapa == "Localidades":
            return QSettings().value('xLocal')
        elif nombreCapa == "Secciones":
            return QSettings().value('xSeccion')
        elif nombreCapa == "Municipios":
            return QSettings().value('xMunicipio')
        elif nombreCapa == "Region Catastral":
            return QSettings().value('xRegion')
        elif nombreCapa == "Estado":
            return QSettings().value('xEstado')
        
        return 'None'

#--------------------------------------------------------------------

    def resetearIntegracion(self):
        self.capaLineas = None
        self.capaPuntos = None
        self.esperandoCarga = False
        self.dlg.fldPuntos.setText('')
        self.dlg.fldLineas.setText('')