# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DivisionFusion
                                 A QGIS plugin
 DivisionFusion
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-05-11
        git sha              : $Format:%H$
        copyright            : (C) 2018 by DivisionFusion
        email                : DivisionFusion
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QSize
from PyQt5.QtGui import QIcon, QColor, QCursor, QPixmap
from PyQt5.QtWidgets import QAction, QMessageBox, QWidget,QVBoxLayout, QPushButton, QTableWidget, QTableWidgetItem
from qgis.core import *
from qgis.gui import QgsRubberBand
from qgis.utils import iface
from PyQt5 import QtCore

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .DivisionFusion_dialog import DivisionFusionDialog
import os.path
from .EventoDivision import EventoDivision
from .VentanaFusionV3 import VentanaFusionV3
from .VentanaClavesV3 import VentanaClavesV3
from .VentanaAreas import VentanaAreas


class DivisionFusion:
    """QGIS Plugin Implementation."""

    def __init__(self, iface, ACA):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        self.CFG = None
        self.UTI = None
        self.DFS = None
        self.DBJ = None
        self.ELM = None
        self.ACA = ACA
        self.TPG = None
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'DivisionFusion_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Create the dialog (after translation) and keep reference
        self.dlg = DivisionFusionDialog(parent = iface.mainWindow())
        #self.dlg.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
        # Declare instance attributes
        '''
        self.actions = []
        self.menu = self.tr(u'&DivisionFusion')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'DivisionFusion')
        self.toolbar.setObjectName(u'DivisionFusion')
        '''

        #self.dlg.setMinimumSize(QSize(464, 465))
        #self.dlg.setMaximumSize(QSize(371, 372))
        #print(self.dlg.size())
        #self.dlg.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
        self.eventos = EventoDivision(iface.mapCanvas(), self)
        self.VentanaAreas = VentanaAreas(self)

        self.VentanaFusion = VentanaFusionV3(iface, self)
        self.VentanaClaves = VentanaClavesV3(iface, self)
        self.rubberMarca = QgsRubberBand(iface.mapCanvas(), QgsWkbTypes.PolygonGeometry)
        self.rubberMarca.setFillColor(QColor(255,255,0,12))
        self.rubberMarca.setStrokeColor(QColor(255,150,0,255))
        self.rubberMarca.setWidth(2)
        self.listaNuevosPredios = []
        self.cargoPredio = False
        self.listaColores = []
        self.rubbersAreas = []

        self.dlg.btnDibujarCortes.setEnabled(False)
        self.dlg.btnEditarCortes.setEnabled(False)
        self.dlg.btnEliminarCortes.setEnabled(False)
        self.dlg.btnApagarHerramientas.setEnabled(False)
        self.dlg.btnConfirmarCortes.setEnabled(False)
        self.dlg.btnDeshacerTodo.setEnabled(False)
        self.dlg.btnCancelarSub.setEnabled(False)
        self.dlg.btnDeshacerCortes.setEnabled(False)
        self.dlg.btnLlamarCalcular.setEnabled(False)

        self.dlg.btnFusionar.clicked.connect(self.preguntarFusion)
        self.dlg.btnCargarPredio.clicked.connect(self.pasarAModoDivision)
        self.dlg.btnConfirmarCortes.clicked.connect(self.confirmarCortes)
        self.dlg.btnDibujarCortes.clicked.connect(self.encenderModoDividir)
        self.dlg.btnEliminarCortes.clicked.connect(self.encenderModoEliminar)
        self.dlg.btnApagarHerramientas.clicked.connect(self.apagarHerramientas)
        self.dlg.btnDeshacerTodo.clicked.connect(self.rollBack)
        self.dlg.btnCancelarSub.clicked.connect(self.cancelarSubdivision)
        self.dlg.btnDeshacerCortes.clicked.connect(self.vaciarLineasCorte)
        self.dlg.btnLlamarCalcular.clicked.connect(self.irAreas)
        self.dlg.btnEditarCortes.clicked.connect(self.encenderModoEditar)

        self.dlg.btnDeshacerTodo.hide()


        self.geomsAreas = []
        #self.p

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('DivisionFusion', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/DivisionFusion/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'DivisionFusion'),
            callback=self.run,
            parent=self.iface.mainWindow())


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&DivisionFusion'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar


    def run(self):
        """Run method that performs all the real work"""
        # show the dialog
        for x in iface.mapNavToolToolBar().actions():
            if x.objectName() == 'mActionPan':
                x.trigger()

        self.dlg.show()
        # Run the dialog event loop
        iface.mapCanvas().setMapTool(self.eventos)
        result = self.dlg.exec_()
        # See if OK was pressed
        self.dlg.btnFusionar.setEnabled(True)
        self.dlg.comboPredios.setEnabled(True)
        self.dlg.btnCargarPredio.setEnabled(True)
        self.dlg.btnDibujarCortes.setEnabled(False)
        self.dlg.btnEditarCortes.setEnabled(False)
        self.dlg.btnEliminarCortes.setEnabled(False)
        self.dlg.btnApagarHerramientas.setEnabled(False)
        self.dlg.btnConfirmarCortes.setEnabled(False)
        self.dlg.btnDeshacerTodo.setEnabled(False)
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

#------------------------------------------------------------------------------

    #Preguntamos si quiere fusionar
    def preguntarFusion(self):
        if iface.activeLayer() != None:
            seleccion = self.iface.activeLayer().selectedFeatures()
            self.VentanaFusion.dlg.close()
            if self.validarCuentaSeleccion(): #Si la seleccion es valida
                
                self.VentanaFusion.dlg.show()
                self.VentanaFusion.llenarTablaComp(seleccion[0], seleccion[1])
                self.dlg.btnCargarPredio.setEnabled(False)
        else:
            self.UTI.mostrarAlerta('La fusion requiere la seleccion de exactamente 2 predios contiguos', QMessageBox().Critical, 'Error de fusion')

#------------------------------------------------------------------

    #Validamosla seleccion
    def validarCuentaSeleccion(self):
        seleccion = self.iface.activeLayer().selectedFeatures()

        if len(seleccion) != 2: #Cuando tenemos seleccionados no 2 elementos
            self.UTI.mostrarAlerta('La fusion requiere la seleccion de exactamente 2 predios contiguos', QMessageBox().Critical, 'Error de fusion')
            return False
        else:
            if not self.validarContiguedad():
                self.UTI.mostrarAlerta('Los predios seleccionados no son contiguos', QMessageBox().Critical, 'Error de fusion')
                return False
            else:
                return True
#-----------------------------------------------------------------------------

    def validarContiguedad(self): #Aqui checamos si dos predios son contiguos
        seleccion = self.iface.activeLayer().selectedFeatures()
        pred1 = seleccion[0].geometry().buffer(0.0000001, 1)
        pred2 = seleccion[1].geometry().buffer(0.0000001, 1)
        #Checamos que el area de interseccion sea un valor considerable
        area = pred1.intersection(pred2).area()
        return area > 0.0000000001

#-----------------------------------------------------------------------------------
    def fusionarPredios(self, eleccion): #Aqui fusionamos los predios

        #OBtener las capas
        capaManzana = QgsProject.instance().mapLayer(self.ACA.obtenerIdCapa('manzana'))
        capaPuntos = QgsProject.instance().mapLayer(self.ACA.obtenerIdCapa('predios.num'))
        capaPredios = QgsProject.instance().mapLayer(self.ACA.obtenerIdCapa('predios.geom'))
        capaConstru = QgsProject.instance().mapLayer(self.ACA.obtenerIdCapa('construcciones'))
        capaCondH = QgsProject.instance().mapLayer(self.ACA.obtenerIdCapa('horizontales.geom'))

        #Puntos y eleccion de victima
        seleccion = self.iface.activeLayer().selectedFeatures()

        listaPuntos = [None, None]

        #Definimos el predio 'victima
        if eleccion == 0:
            victima = 1
        else:
            victima = 0

        #eliminamos el predio no elegido
        self.eliminarNoElegido(seleccion[victima])

        #Eliminar punto del predio no elegido
        for punto in capaPuntos.getFeatures():
            if punto.geometry().intersects(seleccion[victima].geometry()): #Bsucamos el punto del predio victima
                capaPuntos.startEditing()
                capaPuntos.dataProvider().deleteFeatures([punto.id()])
                capaPuntos.triggerRepaint()
                capaPuntos.commitChanges()
                break

        #Generar geometria del predio fusionado
        rango = len(seleccion)
        geomFusion = seleccion[0].geometry()

        featFusion = QgsFeature()
        capaPredios.startEditing()

        #Generar geometria del predio fusionado
        for i in range(0, rango):
            self.iface.activeLayer().dataProvider().deleteFeatures([seleccion[i].id()])
            geomFusion = geomFusion.combine(seleccion[i].geometry())

        #self.geom
        listaFinal = []
        listaPrimera = []
        featFusion.setGeometry(geomFusion)
        
        #Renombrar construcciones
        cuentaConstruccion = 1
        capaConstru.startEditing()

        #--------Renombrar construcciones----
        for construccion in capaConstru.getFeatures():
            geomConstru = construccion.geometry()
            
            if geomConstru.buffer(-0.0000001, 1).intersects(geomFusion):#Sacamos las construcciones dentro del predio fusionado
                listaPrimera.append(construccion)
            else:
                if self.contarIntegraciones( geomConstru.buffer(-0.0000001, 1), 'predios.geom' ) == 0: #Obtenemos los aleros del predio fusionado
                    if geomConstru.buffer(0.0000001, 1).intersection(geomFusion).area() > 0.000000001:
                        #print(geomConstru.buffer(0.0000001, 1).intersection(geomFusion).area())
                        listaPrimera.append(construccion)


        for construccion in listaPrimera:
            geomConstru = construccion.geometry()
            seIncluye = True
            for condominio in capaCondH.getFeatures():
                geomHori = condominio.geometry() 
                if geomConstru.buffer(-0.0000001, 1).intersects(geomHori):
                    seIncluye = False
                    break
                
            if seIncluye:
                listaFinal.append(construccion)



        supConst = 0 #Renombramos ls volumenes
        for construccion in listaFinal:
            geomConstru = construccion.geometry()
            construccion['nom_volumen'] = 'V' + str(cuentaConstruccion)
            niveles = construccion['num_niveles']
            if niveles <= 0:
                niveles = 1
            capaConstru.updateFeature(construccion)
            cuentaConstruccion += 1
            supConst += (geomConstru.area() * niveles)

        capaConstru.commitChanges()
        #----------------------------------------------

        #Estableer atributos del predio fusionado
        idx1 = capaPredios.fields().lookupField('sup_terr')
        idx2 = capaPredios.fields().lookupField('sup_contruccion')
        attr = seleccion[eleccion].attributes()
        attr[idx1] = geomFusion.area()
        attr[idx2] = supConst
        featFusion.setAttributes(attr)
        capaPredios.updateFeature(featFusion)
        capaPredios.dataProvider().addFeatures([featFusion])
        capaPredios.triggerRepaint()
        capaPredios.commitChanges()

        self.UTI.mostrarAlerta('Fusion completada con exito', QMessageBox().Information, 'Fusion de predios')
        self.dlg.close()
        

#-----------------------------------------------------------------------------------

    #Aqui contmaos cuantas geometrias de una capa toca una geomtrias especifica
    def contarIntegraciones(self, geometria, nombreCapa):
        capa = QgsProject.instance().mapLayersByName(nombreCapa)[0]
        cuenta = 0
        for feat in capa.getFeatures():
            if geometria.intersects(feat.geometry()):
                cuenta += 1

        return cuenta

#---------------------------------------------------------------------------

    #Poinemos en lista de eliminados el predio no elegido
    def eliminarNoElegido(self, feat):
        campos = {}
        campos['wkt'] = feat.geometry().asWkt()
        campos['srid'] = 32614

        campos['tabla'] = 'e_predio'
        atributos = {}
        capaPredios = QgsProject.instance().mapLayer(self.ACA.obtenerIdCapa('predios.geom'))
        nombresAtrbutos = capaPredios.fields()   

        nombres = [campo.name() for campo in nombresAtrbutos]

        for x in range(0, len(nombres)):
            atributo = feat.attributes()[x]
            if str(feat.attributes()[x]) == "NULL":
                atributo = None
            atributos[str(nombres[x])] = atributo
            
        campos['attr'] = atributos

        campos['nuevo'] = False
        campos['eliminado'] = True
    
        listaTemp = QSettings().value('listaEliminada')
        listaTemp.append(campos)
        
        QSettings().setValue('listaEliminada', listaTemp)


#--------------------------------------------------------------------------

    #Activamos el modo de division
    def pasarAModoDivision(self):
        clave = self.dlg.comboPredios.currentText() #Obtenemos la clave del predio a editar
        if clave == '':
            self.UTI.mostrarAlerta('Primero debes cargar una manzana de la seccion de consulta', QMessageBox().Critical, 'Error de cargado de predio')
            return

        capaPredios = QgsProject.instance().mapLayer(self.ACA.obtenerIdCapa('predios.geom'))
        #capaPredios.setReadOnly(False)
        #capaPredios.startEditing()

        
        self.predioEnDivision = None

        for predio in capaPredios.getFeatures(): #Obtenemos el feature a dividr con base en la clave elegida
            if predio.attributes()[1] == clave:
                self.predioEnDivision = predio
                break

        if self.predioEnDivision != None:
            
            self.atributosAHeredar = self.predioEnDivision.attributes() #Obtenemos los atributos a heredar
            self.atributosAHeredar[1] = None #Ponemos le id como vacio

            self.rubberMarca.reset(QgsWkbTypes.PolygonGeometry) #Borramos la geometria amarillita
            self.UTI.mostrarAlerta("Dibuja las lineas de corte sobre el predio indicado.\nRecuerda que los cortes no pueden estar sobre construcciones o condiminios.\nAsegurate que las lineas atraviesen el predio por completo\nNOTA: Las lineas solo afectaran al predio seleccionado.", QMessageBox().Information, "Subdivision de predios")
            self.cargoPredio = True
            self.encenderModoDividir() #Encendemos modo dividir

            # marca de amarillo el poligono del predio a subdividir
            self.geomEnDivision = self.predioEnDivision.geometry()
            self.pintarAreaPredioSubdiv()

            # zoom al predio a subdividir
            geometria = self.geomEnDivision

            bbox = geometria.boundingBox()
            iface.mapCanvas().setExtent(bbox)
            iface.mapCanvas().refresh()

            # comportamiento de botones
            self.dlg.btnFusionar.setEnabled(False)
            self.dlg.btnCancelarSub.setEnabled(True)
            self.dlg.btnCargarPredio.setEnabled(False)
            self.dlg.comboPredios.setEnabled(False)
            self.dlg.comboPredios.setEnabled(False)
            self.dlg.btnConfirmarCortes.setEnabled(True)
            self.dlg.btnDeshacerTodo.setEnabled(True)
            self.dlg.btnDeshacerCortes.setEnabled(True)
            self.dlg.btnLlamarCalcular.setEnabled(True)

        else:
            self.UTI.mostrarAlerta('El predio no fue encontrado', QMessageBox().Critical, 'Error de cargado de predio')
        
#-------------------------------------------------------------------------

    def cancelarSubdivision(self):
        
        mensaje = "El modo de division se apagara, el progreso se perdera\nDeseas continuar?"
        respuesta = QMessageBox.question(iface.mainWindow(), "Cancelar subdivision", mensaje, QMessageBox.Yes, QMessageBox.No)

        #Si el usuario acepta....
        if respuesta == QMessageBox.Yes:

            self.vaciarRubbers()
            self.predioEnDivision = None
            self.geomEnDivision = None
            self.modoDividir = False
            self.modoEliminar = False
            self.apagarHerramientas()
            self.dlg.btnCancelarSub.setEnabled(False)
            self.dlg.btnCargarPredio.setEnabled(True)
            self.dlg.comboPredios.setEnabled(True)
            self.dlg.btnFusionar.setEnabled(True)
            self.dlg.btnConfirmarCortes.setEnabled(False)
            self.dlg.btnDeshacerCortes.setEnabled(False)
            self.dlg.btnLlamarCalcular.setEnabled(False)
            self.dlg.btnApagarHerramientas.setEnabled(False)
            self.dlg.btnEliminarCortes.setEnabled(False)
            self.dlg.btnDibujarCortes.setEnabled(False)
            self.dlg.btnEditarCortes.setEnabled(False)
            self.dlg.btnDeshacerTodo.setEnabled(False)
#-----------------------------------------------------------------------------------



#--------------------------------------------

    def confirmarCortes(self): #Aqui cehcamos que los cortes esten en orden
        
        #cuentaCortes = 0
        rango = len(self.eventos.relaciones) - 1
        #for i in range(0, rango):
        #    geom = self.eventos.relaciones[i].geom
        #    if geom != None:
        #        cuentaCortes += 1
        #Obtenemos la cantidad de corte
        #print('cuentaCortes ', cuentaCortes)
        geoTemp = QgsGeometry.fromWkt(self.geomEnDivision.asWkt())
        cuentaSalida = self.subdividirPredio(geoTemp, True) - 1 #Aqui enviamos una geomtria temporal, para ven en cuantos cortes quedara
            
        if cuentaSalida >= 2:

            listaNoTocar = []
            capaPredios = QgsProject.instance().mapLayer(self.ACA.obtenerIdCapa('predios.geom'))
            capaCondH = QgsProject.instance().mapLayersByName('horizontales.geom')[0]
            capaCondV = QgsProject.instance().mapLayersByName('verticales')[0]
            capaConstru = QgsProject.instance().mapLayer(self.ACA.obtenerIdCapa('construcciones'))
            
            #Obtenemos los features que no deben tocarse
            for feat in capaConstru.getFeatures():
                geom = feat.geometry().buffer(-0.0000002, 1)
                if geom.intersects(self.geomEnDivision):
                    listaNoTocar.append(geom)

            for feat in capaCondH.getFeatures():
                geom = feat.geometry().buffer(-0.0000002, 1)
                if geom.intersects(self.geomEnDivision):
                    listaNoTocar.append(geom)

            for feat in capaCondV.getFeatures():
                geom = feat.geometry().buffer(-0.0000002, 1)
                if geom.intersects(self.geomEnDivision):
                    listaNoTocar.append(geom)
            
            bandera = True
            
            #Aqui checamos que cada linea no toque lo no tocable
            for i in range(0, rango):
                for comp in listaNoTocar:
                    geom = self.eventos.relaciones[i].geom
                    if geom != None:
                        if geom.buffer(0.0000001,1).intersects(comp):
                            bandera = False
                            self.eventos.relaciones[i].rubber.setStrokeColor(QColor(255,0,0,255))
                        else:
                            self.eventos.relaciones[i].rubber.setStrokeColor(QColor(0,61,240,255))
            
            iface.mapCanvas().refresh()
            if bandera: #Si todo esta en orden
                self.eventos.rubberPunto.reset(QgsWkbTypes.PointGeometry)
                self.apagarHerramientas()
                #mostramos mensaje de confirmacion
                mensaje = "La cantidad de predios que quedaran como resultado, es de: " + str(cuentaSalida) + "\nDeseas continua?"
                respuesta = QMessageBox.question(iface.mainWindow(), "Nota de subdivision de predio", mensaje, QMessageBox.Yes, QMessageBox.No)

                #Si el usuario acepta....
                if respuesta == QMessageBox.Yes:
                    self.subdividirPredio(self.geomEnDivision, False)
                    self.rubberMarca.reset(QgsWkbTypes.PolygonGeometry) #Quitamos lo amarillito

                    for i in range(0, rango):
                        self.eventos.relaciones[i].rubber.reset(QgsWkbTypes.LineGeometry)
                        self.eventos.relaciones[i].vaciarMarcadores()
                    self.eventos.recargarRelaciones()

                    capaPredios.startEditing()
                    capaPredios.dataProvider().deleteFeatures([self.predioEnDivision.id()])
                    capaPredios.triggerRepaint()
                    capaPredios.commitChanges()

                    self.VentanaAreas.close()
                    self.limpiarAreas()
                    self.vaciarRubbers()

                    self.UTI.mostrarAlerta("La division ha sido realizada con exito\nLos cambios se guardaran hasta que asignes las claves.", QMessageBox().Information, "Subdivision completa, Parte 1 de 2")
                    self.irAClaves() #Mostramos la ventana que llena las claves
                    iface.actionSelect().trigger()
            else:
                self.UTI.mostrarAlerta("Las lineas de division no deben atravesar construcciones ni condominios\nLas lineas rojas presentan un corte invalido", QMessageBox().Critical, "Error en subdivision")
        
        else:
            print('cuentasalida ', cuentaSalida)
            self.UTI.mostrarAlerta("Primero debes dibujar las lineas de corte\nAsegurate que las lineas atraviesen por completo el predio", QMessageBox().Critical, "Error en subdivision")

##################################################################################

    def vaciarLineasCorte(self):
        rango = len(self.eventos.relaciones) - 1 
        for i in range(0, rango):
            self.eventos.relaciones[i].rubber.reset(QgsWkbTypes.LineGeometry)
            self.eventos.relaciones[i].vaciarMarcadores()

        self.eventos.recargarRelaciones()

#-------------------------------------------------------------------------------------

    def subdividirPredio(self, geometria, modoPre): #Subdividir
        capaHori = QgsProject.instance().mapLayersByName('horizontales.geom')[0]
        capaPredio = QgsProject.instance().mapLayer(self.ACA.obtenerIdCapa('predios.geom'))
        capaVert = QgsProject.instance().mapLayersByName('verticales')[0]

        self.listaNuevosPredios = []
        self.geomsAreas = []
        listaParam = [] #La lista que llega al fileteo
        rango = len(self.eventos.relaciones) - 1 
        for i in range(0, rango):

            geom = self.eventos.relaciones[i].geom
            if geom != None:
                listaParam.append(geom.asPolyline()) #Generamos los polyline van a partir

        salida= self.filetear(geometria, listaParam) #Mandamos filetear el poligono con las lineas

        if modoPre: #Si es modoPre, es solo para visaulizar cuantos poligonos quedarian...
            
            for cadaUno in salida:
                self.geomsAreas.append(cadaUno)
            return len(salida)
        else: #Si no, efectuamos realmente el corte
            for cadaUno in salida:
                nuevoFeat = QgsFeature()
                nuevoFeat.setGeometry(cadaUno)
                #Agregamos cada predio a la capa y le ponemos sus atributos
                
                self.asignarAtributos(nuevoFeat)

                capaPredio.startEditing()
                capaPredio.dataProvider().addFeatures([nuevoFeat])
                capaPredio.triggerRepaint()
                capaPredio.commitChanges()

                self.listaNuevosPredios.append(nuevoFeat.geometry().asWkt())
        
        self.apagarHerramientas()
        self.dlg.btnCargarPredio.setEnabled(True)

##################################################################################

    #Metodo para filetear los predios con lineas
    #OJO: Ni se te ocurra moverle aqui karnal, seguramente la vas a pifiar :)
    def filetear(self, poligono, lineas):
        listaActuales = [] #Lista de las geometrias en espera de ser cortadas
        listaActuales.append(poligono) #Agregamos el poligono a cortar en la lista de espera
        listaSiguiente = [poligono]  #Agregamos le poligono a cortar en la lista de la siguiente interacion

        for linea in lineas: #Iteramos cada linea de corte

            listaActuales = listaSiguiente #Igualamos la lista de corte a la iteracion anterior
            listaSiguiente =  [] #Vaciamos la lista que dara lugar a la siguiente iteracion de corte
            
            for actual in listaActuales: #Checamos cada geometria en espera
                
                partida = actual.splitGeometry(linea, True) #Aplicamos el split geometry de qgis, vamos partiendo el poligono, tut, tut, tut
                if len(partida[1]) == 0: #Esto ocurre cuando el corte no hizo nada
                    listaSiguiente.append(actual) #Asi que nos quedamos con la geometria tal cual esta
                else: #Cuando si hubo corte
                    parte1 = partida[1][0] #obtenemos la geometria resultante del corte, VER DOCUMENTACION DE SPLITGEOMETRY PARA ENTENDER
                    parte2 = actual.difference(parte1) #Al poligono que se corto, le quitamos la parte previa al corte anterior
                    #De esta forma nos quedamos con la geometria partida en 2

                    if parte1.area() > 0.0: #Checamos que el area de esta parte sea mayor que 0, por motivos de los decimales
                        listaSiguiente.append(parte1) #Si es asi, significa un fragmento que puede ser cortado por otra linea
                    
                    if parte2.area() > 0.0: #Lo mismo
                        listaSiguiente.append(parte2)

        temporal = poligono #Obtenemos una geometria igualita al poligono entrannte

        for geomSal in listaSiguiente: #Obtenemos las diferencia respeto a los poligonos obtenidos y el entrante, lo que resulte, tambien es parte del corte
            temporal = temporal.difference(geomSal.buffer(0.0000001,1))
            #El buffer tu sabes por que es, si llegaste hasta aqui y no sabes por que le ponemos buffer, mejor quita los cambios que hiciste colega, seguramente la pifiaste :)

        listaSiguiente.append(temporal) #Aqui ponemos todas las geometrias
        return listaSiguiente #Retornamos la lista

#-------------------------------------------------------------------------

    def encenderModoDividir(self): #Activamos el modo de dividir
        
        self.eventos.modoDividir = True
        self.eventos.modoEliminar = False
        self.eventos.modoEditar = False
        self.dlg.btnDibujarCortes.setEnabled(False)
        self.dlg.btnEditarCortes.setEnabled(True)
        self.dlg.btnEliminarCortes.setEnabled(True)
        self.dlg.btnApagarHerramientas.setEnabled(True)
        self.dlg.btnConfirmarCortes.setEnabled(True)
        self.dlg.btnDeshacerTodo.setEnabled(True)
        self.dlg.btnCargarPredio.setEnabled(False)
        #iface.mapCanvas().setCursor(self.DBJ.eventos.cursorRedondo)
        iface.mapCanvas().setCursor(self.UTI.cursorRedondo)

#----------------------------------------------------------------------------

    def encenderModoEditar(self): #Activamos el modo de dividir
        
        self.eventos.modoDividir = False
        self.eventos.modoEliminar = False
        self.eventos.modoEditar = True
        self.dlg.btnDibujarCortes.setEnabled(True)
        self.dlg.btnEditarCortes.setEnabled(False)
        self.dlg.btnEliminarCortes.setEnabled(True)
        self.dlg.btnApagarHerramientas.setEnabled(True)
        self.dlg.btnConfirmarCortes.setEnabled(True)
        self.dlg.btnDeshacerTodo.setEnabled(True)
        self.dlg.btnCargarPredio.setEnabled(False)
        #iface.mapCanvas().setCursor(self.DBJ.eventos.cursorRedondo)
        iface.mapCanvas().setCursor(self.UTI.cursorRedondo)

#----------------------------------------------------------------------------

    def encenderModoEliminar(self): #Activamos el modo de eliminar
        self.eventos.modoDividir = False
        self.eventos.modoEliminar = True
        self.eventos.modoEditar = False
        self.dlg.btnDibujarCortes.setEnabled(True)
        self.dlg.btnEditarCortes.setEnabled(True)
        self.dlg.btnEliminarCortes.setEnabled(False)
        self.dlg.btnApagarHerramientas.setEnabled(True)
        self.dlg.btnConfirmarCortes.setEnabled(True)
        self.dlg.btnCargarPredio.setEnabled(False)
        #iface.mapCanvas().setCursor(self.DBJ.eventos.cursorCuadro)
        iface.mapCanvas().setCursor(self.UTI.cursorCuadro)

#----------------------------------------------------------------------------

    def apagarHerramientas(self): #Apagamos las herramientas
        self.eventos.modoDividir = False
        self.eventos.modoEliminar = False
        self.eventos.modoEditar = False

        self.dlg.btnDibujarCortes.setEnabled(True)
        self.dlg.btnEliminarCortes.setEnabled(True)
        self.dlg.btnEditarCortes.setEnabled(True)
        self.dlg.btnApagarHerramientas.setEnabled(False)
        self.dlg.btnConfirmarCortes.setEnabled(True)
        self.dlg.btnCargarPredio.setEnabled(False)
        #iface.mapCanvas().setCursor(self.DBJ.eventos.cursorCruz)
        iface.mapCanvas().setCursor(self.UTI.cursorCruz)

#-----------------------------------------------------------------

    def rollBack(self): #Deshacemos cambios

        mensaje = "Todos los cambio se perderan, el area de trabajo se limpiara... deseas continuar?"
        respuesta = QMessageBox.question(iface.mainWindow(), "Cancelar cambios", mensaje, QMessageBox.Yes, QMessageBox.No)

        #Si el usuario acepta....
        if respuesta == QMessageBox.Yes:

            self.eventos.modoDividir = False
            self.eventos.modoEliminar = False
            self.dlg.close()
            self.VentanaClaves.dlg.close()
            self.vaciarRubbers()
            self.predioEnDivision = None
            self.geomEnDivision = None
            self.VentanaAreas.close()
            self.UTI.limpiarCanvas()
            
        

#------------------------------------------------------------

    def vaciarRubbers(self):
        rango = len(self.eventos.relaciones) - 1 
        for i in range(0, rango):
            self.eventos.relaciones[i].rubber.reset(QgsWkbTypes.LineGeometry)
            #self.eventos.relaciones[i].geom = None
            self.eventos.relaciones[i].vaciarMarcadores()

        self.eventos.recargarRelaciones()
        self.rubberMarca.reset(QgsWkbTypes.PolygonGeometry)
        #self.eventos.vaciarMarcadores()

#-----------------------------------------------------------------

    def asignarAtributos(self, feat): #Asignamos los atributos
        capaPredios = QgsProject.instance().mapLayer(self.ACA.obtenerIdCapa('predios.geom'))
        campos = capaPredios.fields()   
        nombres = [campo.name() for campo in campos]

        listaAsignacion = []

        for nombre in nombres:
            idx = capaPredios.fields().lookupField(nombre)
            if nombre == 'sup_terr':
                attr = feat.geometry().area()
            elif nombre == 'sup_contruccion':
                attr = self.calcularSupConst(feat)
            elif nombre == 'clave':
                attr = ''
            elif nombre == 'cve_cat':
                attr = ''
            elif nombre == 'id':
                attr = ''
            else:
                attr = self.predioEnDivision.attributes()[idx]
            listaAsignacion.append(attr)
        
        capaPredios.startEditing()
        feat.setAttributes(listaAsignacion)
        capaPredios.triggerRepaint()
        capaPredios.commitChanges()

#------------------------------------------------------------

    def calcularSupConst(self, feat): #calculamos superficie de construccion
        
        capaConstru = QgsProject.instance().mapLayer(self.ACA.obtenerIdCapa('construcciones'))
        capaCondH = QgsProject.instance().mapLayer(self.ACA.obtenerIdCapa('horizontales.geom'))

        listaFinal = []
        listaPrimera = []
        
        
        #Renombrar construcciones
        cuentaConstruccion = 1
        capaConstru.startEditing()
        geomFeat = feat.geometry()

        #--------Renombrar construcciones----
        for construccion in capaConstru.getFeatures():
            geomConstru = construccion.geometry()
            
            if geomConstru.buffer(-0.0000001, 1).intersects(geomFeat):#Sacamos las construcciones dentro del predio fusionado
                listaPrimera.append(construccion)
            else:
                if self.contarIntegraciones( geomConstru.buffer(-0.0000001, 1), 'predios.geom' ) == 0: #Obtenemos los aleros del predio fusionado
                    if geomConstru.buffer(0.0000001, 1).intersection(geomFeat).area() > 0.000000001:
                        #print(geomConstru.buffer(0.0000001, 1).intersection(geomFusion).area())
                        listaPrimera.append(construccion)


        for construccion in listaPrimera:
            geomConstru = construccion.geometry()
            seIncluye = True
            for condominio in capaCondH.getFeatures():
                geomHori = condominio.geometry() 
                if geomConstru.buffer(-0.0000001, 1).intersects(geomHori):
                    seIncluye = False
                    break
                
            if seIncluye:
                listaFinal.append(construccion)

        supConst = 0 #Renombramos ls volumenes
        for construccion in listaFinal:
            geomConstru = construccion.geometry()
            construccion['nom_volumen'] = 'V' + str(cuentaConstruccion)
            niveles = construccion['num_niveles']
            if niveles <= 0:
                niveles = 1
            capaConstru.updateFeature(construccion)
            cuentaConstruccion += 1
            supConst += (geomConstru.area() * niveles)
        
        return supConst
        
#--------------------------------------------------------------------------------------------------

    def irAClaves(self): #Pintamos la ventanita de asignar clavees
        self.VentanaClaves.rellenarClaves()
        self.VentanaClaves.llenar(False)
        self.VentanaClaves.dlg.show()
        self.dlg.btnDibujarCortes.setEnabled(False)
        self.dlg.btnEditarCortes.setEnabled(False)
        self.dlg.btnEliminarCortes.setEnabled(False)
        self.dlg.btnApagarHerramientas.setEnabled(False)
        self.dlg.btnConfirmarCortes.setEnabled(False)
        self.dlg.btnCargarPredio.setEnabled(False)
        self.dlg.btnDeshacerCortes.setEnabled(False)
        self.dlg.btnLlamarCalcular.setEnabled(False)
        self.dlg.btnCancelarSub.setEnabled(False)
        self.dlg.comboPredios.setEnabled(False)
        self.enClaves = True
        
#-------------------------------------------------------------------------

    def irAreas(self):
        
        self.limpiarAreas()
        self.rubberMarca.reset(QgsWkbTypes.PolygonGeometry)
        geoTemp = QgsGeometry.fromWkt(self.geomEnDivision.asWkt())

        print('------------------')
        print()
        print()
        print(geoTemp)
        print()
        print()
        print('------------------')

        self.subdividirPredio(geoTemp, True)
        self.listaColores = []
        for geom in self.geomsAreas:
            if geom.area() <= 0:
                continue
            newRub = self.eventos.crearNuevoRubberPoly()
            
            # obtener una lista de vertices del tipo QgsPointXY
            listaVertices = self.UTI.obtenerVerticesPoligono(geom)

            listaVertices.append(listaVertices[0])
            rangoVertices = len(listaVertices)
            for x in range(0, rangoVertices-2):
                newRub.addPoint(listaVertices[x], True)

            newRub.show()
            self.rubbersAreas.append(newRub)

        self.VentanaAreas.mostrarAreas()
            
#--------------------------------------------------------------------

    def limpiarAreas(self):
        for rub in self.rubbersAreas:
            rub.reset(QgsWkbTypes.PolygonGeometry)

        self.rubbersAreas = []

#------------------------------------------------------------------

    def quitarAreas(self):
        self.limpiarAreas()

        n   = 0 #Obtenemos todos los vertices de la geometria en division
        if self.geomEnDivision == None:
            return
        
        self.pintarAreaPredioSubdiv()
        '''
        ver = self.geomEnDivision.vertexAt(0)
        listaVertices = []
        while(ver != QgsPoint(0,0)):
            n +=1
            ver=self.geomEnDivision.vertexAt(n)
            listaVertices.append(ver)


        listaVertices.append(listaVertices[0])
        rangoVertices = len(listaVertices)
        for x in range(0, rangoVertices-2):
            vertice = listaVertices[x]
            self.rubberMarca.addPoint(QgsPointXY(vertice.x(), vertice.y()), True)
        self.rubberMarca.show() #Aqui pintamos de amarillito la geometria en division
        '''


#--------------------------------------------------------------------------

    def pintarAreaPredioSubdiv(self, geom = None):

        if geom is None:
            geom = self.geomEnDivision

        polygon = geom.asPolygon()
        listaVertices = []

        n = len(polygon[0])

        for i in range(n):
            listaVertices.append(polygon[0][i])

        listaVertices.append(listaVertices[0])
        rangoVertices = len(listaVertices)
        for x in range(0, rangoVertices-2):
            self.rubberMarca.addPoint(listaVertices[x], True)
        self.rubberMarca.show() #Aqui pintamos de amarillito la geometria en division

    def closeEvent(self, evnt):
        if self.enClaves:
            evnt.ignore()
