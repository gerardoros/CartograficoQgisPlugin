# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AsignacionPadron
                                 A QGIS plugin
 AsignacionPadron
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-07-25
        git sha              : $Format:%H$
        copyright            : (C) 2018 by AsignacionPadron
        email                : AsignacionPadron
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .AsignacionPadron_dialog import AsignacionPadronDialog
from .VentanaAsignacionPadron import VentanaAsignacionPadron
import os.path
from PyQt5 import QtCore
from PyQt5 import QtWidgets
import os.path
import os, json, requests
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *
from qgis.core import *
from osgeo import ogr, osr

class AsignacionPadron:
    """QGIS Plugin Implementation."""

    def __init__(self, iface, UTI):
        
        # Save reference to the QGIS interface
        self.iface = iface
        self.dlg = AsignacionPadronDialog()

        #self.dlg.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
        self.UTI = UTI

        self.modeloLocalidad = QStandardItemModel()
        self.enviosLocalidad = []
        self.modeloSector = QStandardItemModel()
        self.enviosSector = []
        self.modeloManzana = QStandardItemModel()
        self.enviosManzana = []

        self.clavesIzq = []
        self.clavesDer = {}

        self.dlg.cmbLocalidad.currentIndexChanged.connect(self.obtenerSectoresPorLocalidad)
        self.dlg.cmbSector.currentIndexChanged.connect(self.obtenerManzanasPorSector)
        self.dlg.cmbManzana.currentIndexChanged.connect(self.contactarPintarCampos)
        
        self.dlg.cmbLocalidad.highlighted.connect(self.bypassSectorLoc)
        self.dlg.cmbSector.highlighted.connect(self.bypassManzanaSector)
        self.dlg.cmbManzana.highlighted.connect(self.bypassPintar)

        self.VentanaLiberacion = VentanaAsignacionPadron(iface, self)

        self.dlg.btnMas.clicked.connect(self.pasarDerecha)
        self.dlg.btnMenos.clicked.connect(self.pasarIzquierda)

        self.dlg.chkTodoClaves.stateChanged.connect(self.marcarTodoClaves)
        self.dlg.chkTodoMazPred.stateChanged.connect(self.marcarTodoMazPred)
        self.dlg.tablaMazPred.hideColumn(0)

        self.dlg.btnAsignar.clicked.connect(self.asignarRevision)
        self.dlg.btnLiberarAsig.clicked.connect(self.llamarLiberar)

        self.diccionarioAsignaciones = {}
        self.llaveManzana = None

        self.manzanaCargada = -1
        self.localidadCargado = -1
        self.sectorCargado = -1
        self.resetar()

        self.indexCompLocalidad = -1
        self.indexCompSector = -1
        self.indexCompManzana = -1

        self.bypass = False

    def bypassSectorLoc(self, index):
        #print('se acrtivooooo')
        self.bypass = True
        #self.obtenerSectoresPorLocalidad()

    def bypassManzanaSector(self, index):
        self.bypass = True
        #self.obtenerManzanasPorSector()

    def bypassPintar(self, index):
        self.bypass = True
        #self.contactarPintarCampos()

    def run(self):
        """Run method that performs all the real work"""
        # show the dialog
        self.resetar()
        self.dlg.show()
        #self.obtenerLocalidades()
        self.UTI.strechtTabla(self.dlg.tablaClaves)
        self.UTI.strechtTabla(self.dlg.tablaMazPred)
        self.llenarUsuarios()
        self.capaPredios = QgsProject.instance().mapLayer(self.ACA.obtenerIdCapa('predios.geom'))
        self.capaConH = QgsProject.instance().mapLayer(self.ACA.obtenerIdCapa('horizontales.geom'))
        self.capaConV = QgsProject.instance().mapLayer(self.ACA.obtenerIdCapa('verticales'))
        self.capaConVC = QgsProject.instance().mapLayer(self.ACA.obtenerIdCapa('cves_verticales'))
        #self.contactarPintarCampos()
        self.obtenerLocalidades()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            pass

#_-------------------------------------------------------------------------------------------------

    def obtenerLocalidades(self):

        self.dlg.cmbLocalidad.clear()

        try:
            headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}
            respuesta = requests.get(self.CFG.urlLocalidades, headers = headers)
        except requests.exceptions.RequestException:
            self.UTI.mostrarAlerta("Error de servidor LOC01", QMessageBox().Critical, "Cargar Localidades")
            print('ERROR: LOC000')

        lenJson = len(list(respuesta.json()))

        if lenJson > 0:
            listaTemp = ['--Selecciona--']
            
            self.enviosLocalidad = ['-']
            for localidad in respuesta.json():
                listaTemp.append(str(localidad['label']) + " " + localidad['other'])
                self.enviosLocalidad.append(str(localidad['value']))

            modeloTemp = QStandardItemModel()
            for i,word in enumerate( listaTemp ):   
                
                item = QStandardItem(word)
                modeloTemp.setItem(i, 0, item)

            
            self.UTI.extenderCombo(self.dlg.cmbLocalidad, self.completarLocalidad, modeloTemp)
            self.dlg.cmbLocalidad.model().item(0).setEnabled(False)
        else:
            self.dlg.cmbLocalidad.setEnabled(False)
            self.dlg.cmbLocalidad.clear()
            self.dlg.cmbSector.setEnabled(False)
            self.dlg.cmbSector.clear()
            self.dlg.cmbManzana.setEnabled(False)
            self.dlg.cmbManzana.clear()
            self.clavesIzq = []
            self.llaveManzana = None
            self.vaciarTabla(self.dlg.tablaClaves)
            self.UTI.mostrarAlerta("No existen localidades registradas", QMessageBox().Information, "Cargar Localidades")

#-----------------------------------------------------------------------------------------

    #Llenar segundo combo
    def obtenerSectoresPorLocalidad(self):

        #print('lo tiro una vez')
        index = self.dlg.cmbLocalidad.currentIndex()
        
        #print('tenemos ', index, self.indexCompLocalidad, self.bypass)
        if index == self.indexCompLocalidad or self.bypass:
            #self.indexCompLocalidad = -1
            #print('pasooooo')

            self.manzanaCargada = -1
            self.sectorCargado = -1

            self.bypass = False
            self.dlg.cmbManzana.setEnabled(False)
            self.dlg.cmbManzana.clear()

            if self.dlg.cmbLocalidad.count() > 0 and index > 0:

                index = self.dlg.cmbLocalidad.currentIndex()

                try:
                    idSector = self.enviosLocalidad[index]

                    if self.localidadCargado == idSector:
                        print('SECTOR POR LOCALIDAD RETORNADOS')
                        return
                    self.localidadCargado = idSector

                except:
                    return
                
                self.dlg.cmbSector.clear()

                try:
                    headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}
                    respuesta = requests.get(self.CFG.urlSectores + idSector + '/sector/', headers = headers)
                except requests.exceptions.RequestException:
                    self.UTI.mostrarAlerta("Error de servidor SEC01", QMessageBox().Critical, "Cargar Sectores")
                    print('ERROR: SEC000')

                lenJson = len(list(respuesta.json()))

                if lenJson > 0:
                    listaTemp = ['--Selecciona--']
                    self.enviosSector = ['-']
                    for sector in respuesta.json():
                        listaTemp.append(sector['label'])
                        self.enviosSector.append(sector['value'])
                    modeloTemp = QStandardItemModel()
                    for i,word in enumerate( listaTemp ):   
                        
                        item = QStandardItem(word)
                        modeloTemp.setItem(i, 0, item)

                    
                    self.UTI.extenderCombo(self.dlg.cmbSector, self.completarSector, modeloTemp)
                    self.dlg.cmbSector.model().item(0).setEnabled(False)
                    self.dlg.cmbSector.setEnabled(True)
                else:
                    self.dlg.cmbSector.setEnabled(False)
                    self.dlg.cmbSector.clear()
                    
                    self.clavesIzq = []
                    self.vaciarTabla(self.dlg.tablaClaves)
                    self.llaveManzana = None

                    self.UTI.mostrarAlerta("No existen sectores en la localidad", QMessageBox().Information, "Cargar Sectores")

#--------------------------------------------------------------------------------------------------------------

    def obtenerManzanasPorSector(self):
    
        index = self.dlg.cmbSector.currentIndex()

        if index == self.indexCompSector or self.bypass:

            self.bypass = False
            if self.dlg.cmbSector.count() > 0 and index > 0:
                #self.indexCompSector = -1
                index = self.dlg.cmbSector.currentIndex()

                try:
                    idSector = self.enviosSector[index]

                    if self.sectorCargado == idSector:
                        print('MANZANA POR SECTOR RETORNADOS')
                        return
                    self.sectorCargado = idSector
                except:
                    return

                self.dlg.cmbManzana.clear()

                try:
                    headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}
                    respuesta = requests.get(self.CFG.urlManzanas + idSector + '/manzana/', headers = headers)
                except requests.exceptions.RequestException:
                    self.UTI.mostrarAlerta("Error de servidor MAN01", QMessageBox().Critical, "Cargar Manzanas")
                    print('ERROR: MAN000')

                lenJson = len(list(respuesta.json()))

                if lenJson > 0:
                    listaTemp = ['--Selecciona--']
                    self.enviosManzana = ['-']
                    for manzana in respuesta.json():
                        listaTemp.append(manzana['label'])
                        self.enviosManzana.append(manzana['other'])
                    modeloTemp = QStandardItemModel()
                    for i,word in enumerate( listaTemp ):   
                        
                        item = QStandardItem(word)
                        modeloTemp.setItem(i, 0, item)

                    
                    self.UTI.extenderCombo(self.dlg.cmbManzana, self.completarManzana, modeloTemp)
                    self.dlg.cmbManzana.model().item(0).setEnabled(False)
                    self.dlg.cmbManzana.setEnabled(True)
                else:
                    self.dlg.cmbManzana.setEnabled(False)
                    self.dlg.cmbManzana.clear()
                    self.clavesIzq = []
                    self.vaciarTabla(self.dlg.tablaClaves)
                    self.llaveManzana = None
                    self.UTI.mostrarAlerta("No existen manzanas en el sector", QMessageBox().Information, "Cargar Manzanas")

#---------------------------------------------------------------------------------------------------------------

    def contactarPintarCampos(self):
        print('entro al pintar camposss')
        index = self.dlg.cmbManzana.currentIndex()

        if index == self.indexCompManzana or self.bypass:
            #self.indexCompManzana = -1
            self.bypass = False
            if self.validarCombox and index > 0:
                self.ACA.obtenerXCapas()
                cuerpo = {"incluirGeom": "true", "pagina": None, "bbox": "false", "pin": "false", "geomWKT": None, "epsg": None, "properties": None, "epsgGeomWKT": None, "itemsPagina": None, "nombre": "x"}
                payload = json.dumps(cuerpo)
                self.ACA.payload = payload
                index = self.dlg.cmbManzana.currentIndex()
                self.ACA.idManzana = self.enviosManzana[index]

                if self.manzanaCargada == self.enviosManzana[index]:
                    print('SE RETORNO')
                    return
                self.manzanaCargada = self.enviosManzana[index]
                
                self.llaveManzana = self.enviosManzana[index]
                self.ACA.pintarCapasCampo()

                self.llenadoDeTablas()
                self.manzanaCargada = -1
                self.localidadCargado = -1
                self.sectorCargado = -1
            
#----------------------------------------------------------------------------------------------------------------

    def llenadoDeTablas(self):
        self.obtenerDiccionarioAsignaciones()

        keysDer = list(self.clavesDer.keys())
        keysAsig = list(self.diccionarioAsignaciones.keys())
        self.clavesIzq = []

        clavesPerronas = []
        filtro = []

        if self.llaveManzana == None:
            return

        if self.llaveManzana in keysDer: #Si la llave manzana ya existe en la tabla derecha...
            
            for predio in self.capaPredios.getFeatures():
                listaH = self.listaCondominiosH(predio)
                listaV = self.listaCondominiosV(predio)
                
                for cond in listaH:
                    cveCat = predio['clave'] + cond
                    if not cveCat in self.clavesDer[self.llaveManzana]: #Si la clave del predio no esta en el lado derecho...
                        filtro.append(cveCat)

                for cond in listaV:
                    listaVC = self.listaCondominiosVC(cond)
                    for vc in listaVC:
                        cveCat = predio['clave'] + cond['clave'] + vc
                        if not cveCat in self.clavesDer[self.llaveManzana]: #Si la clave del predio no esta en el lado derecho...
                            filtro.append(cveCat)
                
                cveCat = predio['clave'] + '000000'
                if not cveCat in self.clavesDer[self.llaveManzana]: #Si la clave del predio no esta en el lado derecho...
                    filtro.append(cveCat)
                    
        else: #Si la llave de manzanaaun no la tenemos...
            self.clavesDer[self.llaveManzana] = [] #La agregamos al lado derecho pero vacia...
            for predio in self.capaPredios.getFeatures():
                listaH = self.listaCondominiosH(predio)
                listaV = self.listaCondominiosV(predio)
                
                for cond in listaH:
                    cveCat = predio['clave'] + cond
                    if not cveCat in self.clavesDer[self.llaveManzana]: #Si la clave del predio no esta en el lado derecho...
                        filtro.append(cveCat)

                for cond in listaV:
                    listaVC = self.listaCondominiosVC(cond)
                    for vc in listaVC:
                        cveCat = predio['clave'] + cond['clave'] + vc
                        if not cveCat in self.clavesDer[self.llaveManzana]: #Si la clave del predio no esta en el lado derecho...
                            filtro.append(cveCat)
                
                cveCat = predio['clave'] + '000000'
                if not cveCat in self.clavesDer[self.llaveManzana]: #Si la clave del predio no esta en el lado derecho...
                    filtro.append(cveCat)

        if self.llaveManzana in keysAsig:
            for clave in filtro:
                if not clave in self.diccionarioAsignaciones[self.llaveManzana]: #Si la clave del predio no esta en el lado derecho...
                    clavesPerronas.append(clave)
        else:
            for clave in filtro:
                clavesPerronas.append(clave)
                
        for clave in clavesPerronas:
            self.clavesIzq.append(clave)

        self.clavesIzq.sort() 
        self.actualizarTablas()

#-----------------------------------------------------------------------------------------------------------------

    def listaCondominiosH(self, predio):
        
        listaSalida = []
        for cond in self.capaConH.getFeatures():
            geomCond = cond.geometry()
            if geomCond.buffer(-0.0000001, 1).intersects(predio.geometry()):
                listaSalida.append(cond['clave'])

        return listaSalida

#---------------------------------------------------------------------------

    def listaCondominiosVC(self, condV):
        
        listaSalida = []
        for cond in self.capaConVC.getFeatures():
            geomCond = cond.geometry()
            if geomCond.intersects(condV.geometry()):
                listaSalida.append(cond['clave'])

        return listaSalida

#---------------------------------------------------------------------------------------------------

    def listaCondominiosV(self, predio):
        listaSalida = []
        for cond in self.capaConV.getFeatures():
            geomCond = cond.geometry()
            if geomCond.buffer(-0.0000001, 1).intersects(predio.geometry()):
                listaSalida.append(cond)

        return listaSalida

#------------------------------------------------------------------------------------------------------------

    def validarCombox(self):
        return (self.dlg.cmbLocalidad.count() > 0 and self.dlg.cmbSector.count() > 0 and self.dlg.cmbManzana.count() >0)

#--------------------------------------------------------------------------------------------------------------------

    def actualizarTablas(self):
        self.llenarTablaIzquierda()
        self.llenarTablaDerecha()

#--------------------------------------------------------------------------------------------------------
    def llenarTablaIzquierda(self):
        
        self.vaciarTabla(self.dlg.tablaClaves)

        #for clave in listaClaves:
        for x in range(0, len(self.clavesIzq)):
            self.dlg.tablaClaves.insertRow(x)

            item = QtWidgets.QTableWidgetItem(self.clavesIzq[x])
            item.setFlags( QtCore.Qt.ItemIsUserCheckable |  QtCore.Qt.ItemIsEnabled )
            item.setCheckState(QtCore.Qt.Unchecked)
            self.dlg.tablaClaves.setItem(x, 0 , item)


#-------------------------------------------------------------------------------------------------

    def llenarTablaDerecha(self):
        
        self.vaciarTabla(self.dlg.tablaMazPred)
        keysDer = list(self.clavesDer.keys())
        for key in keysDer:

            listaKey = self.clavesDer[key]
            for x in range(0, len(listaKey)):
                
                rowCount = self.dlg.tablaMazPred.rowCount()
                self.dlg.tablaMazPred.insertRow(rowCount)
                rowCount = self.dlg.tablaMazPred.rowCount()

                item = QtWidgets.QTableWidgetItem(str(key))
                self.dlg.tablaMazPred.setItem(rowCount-1, 0 , item)
                item.setFlags( QtCore.Qt.ItemIsSelectable |  QtCore.Qt.ItemIsEnabled )

                item = QtWidgets.QTableWidgetItem(str(key)[-3:])
                self.dlg.tablaMazPred.setItem(rowCount-1, 1 , item)
                item.setFlags( QtCore.Qt.ItemIsUserCheckable |  QtCore.Qt.ItemIsEnabled )
                item.setCheckState(QtCore.Qt.Unchecked)

                item = QtWidgets.QTableWidgetItem(str(listaKey[x]))
                self.dlg.tablaMazPred.setItem(rowCount-1, 2 , item)
                item.setFlags( QtCore.Qt.ItemIsSelectable |  QtCore.Qt.ItemIsEnabled )
                
#-------------------------------------------------------------------------------------------------------

    def pasarDerecha(self):

        indexSel = []
        for c in range(0, self.dlg.tablaClaves.rowCount()):
            if self.dlg.tablaClaves.item(c, 0 ).checkState() == QtCore.Qt.Checked:
                indexSel.append(c)
        
        if len(indexSel) > 0:
            listaQuitados = []
            for index in indexSel:
                item = self.clavesIzq[index]
                listaQuitados.append(item)
                self.clavesDer[self.llaveManzana].append(item)
            
            for quitado in listaQuitados:
                self.clavesIzq.remove(quitado)
                
            self.clavesDer[self.llaveManzana].sort()
            self.dlg.chkTodoClaves.setCheckState(QtCore.Qt.Unchecked)
            self.actualizarTablas()

#---------------------------------------------------------------------------------------------------

    def pasarIzquierda(self):
        indexSel = []
        for c in range(0, self.dlg.tablaMazPred.rowCount()):
            if self.dlg.tablaMazPred.item(c, 1 ).checkState() == QtCore.Qt.Checked:
                indexSel.append(c)

        if len(indexSel) >0:

            for index in indexSel:
                key = str(self.dlg.tablaMazPred.item(index, 0).text())
                data = str(self.dlg.tablaMazPred.item(index, 2).text())
                self.clavesDer[str(key)].remove(str(data))
            
                if key == self.llaveManzana:
                    self.clavesIzq.append(data)

            self.dlg.chkTodoMazPred.setCheckState(QtCore.Qt.Unchecked)
            self.clavesIzq.sort()
            self.actualizarTablas()

#----------------------------------------------------------------------------------------------------

    def marcarTodoClaves(self):
        if self.dlg.chkTodoClaves.checkState() == QtCore.Qt.Checked:
            if self.dlg.tablaClaves.rowCount() > 0:
                for c in range(0, self.dlg.tablaClaves.rowCount()):
                    self.dlg.tablaClaves.item(c, 0 ).setCheckState(QtCore.Qt.Checked)
            else:
                self.dlg.chkTodoClaves.setCheckState(QtCore.Qt.Unchecked)
        else:
            for c in range(0, self.dlg.tablaClaves.rowCount()):
                self.dlg.tablaClaves.item(c, 0 ).setCheckState(QtCore.Qt.Unchecked)

#----------------------------------------------------------------------------------------------------

    def marcarTodoMazPred(self):
        if self.dlg.chkTodoMazPred.checkState() == QtCore.Qt.Checked:
            if self.dlg.tablaMazPred.rowCount() > 0:
                for c in range(0, self.dlg.tablaMazPred.rowCount()):
                    self.dlg.tablaMazPred.item(c, 1 ).setCheckState(QtCore.Qt.Checked)
            else:
                self.dlg.chkTodoMazPred.setCheckState(QtCore.Qt.Unchecked)
        else:
            for c in range(0, self.dlg.tablaMazPred.rowCount()):
                self.dlg.tablaMazPred.item(c, 1 ).setCheckState(QtCore.Qt.Unchecked)                

#------------------------------------------------------------------------------------------------------------
    def vaciarTabla(self, tabla):
        tabla.clearContents()
        tabla.setRowCount(0)
            
        for row in range(0, tabla.rowCount()):        
            tabla.removeRow(row) 



#--------------------------------------------------------------------------------------------------------------

    def completarLocalidad(self, text):
        
        #print('entro al de afuera')
        if text:
            #print('entro al de adentro con ', text)
            index = self.dlg.cmbLocalidad.findText(text)
            self.indexCompLocalidad = index
            #print('indice a completa', index)
            self.dlg.cmbLocalidad.setCurrentIndex(index)

#----------------------------------------------------------------------------------------------------------------------

    def completarSector(self, text):
        
        if text:
            index = self.dlg.cmbSector.findText(text)
            self.indexCompSector = index
            self.dlg.cmbSector.setCurrentIndex(index)

#---------------------------------------------------------------------------------------------------------------------

    def completarManzana(self, text):
        
        if text:
            
            index = self.dlg.cmbManzana.findText(text)
            self.indexCompManzana = index
            self.dlg.cmbManzana.setCurrentIndex(index)

#---------------------------------------------------------------------------------------------------

    def completarUsuario(self, text):
        
        if text:
            index = self.dlg.cmbUsuario.findText(text)
            self.dlg.cmbUsuario.setCurrentIndex(index)

#----------------------------------------------------------------------------------------------------------

    def obtenerDiccionarioAsignaciones(self):
        
        self.diccionarioAsignaciones = {}
        try:
            headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}
            respuesta = requests.get(self.CFG.urlAsigPadTodos, headers = headers)

            if respuesta.status_code == 200:
                
                for cadaUno in respuesta.json():

                    cveCat = cadaUno['cveCatastral']
                    cvePredio = cveCat[-11:]
                    cveManzana = cveCat[0:20]
                    
                    llavesDic = self.diccionarioAsignaciones.keys()
                    if not cveManzana in llavesDic:
                        self.diccionarioAsignaciones[cveManzana] = []

                    self.diccionarioAsignaciones[cveManzana].append(cvePredio)

            else:
                print(respuesta)
                self.UTI.mostrarAlerta("Error de servidor DICACC1", QMessageBox().Critical, "Cargar Sectores")

        except requests.exceptions.RequestException:
            self.UTI.mostrarAlerta("Error de servidor DICACC2", QMessageBox().Critical, "Cargar Sectores")
        
#-------------------------------------------------------------------------------------------------------------

    def asignarRevision(self):

        indiceUsuario = self.dlg.cmbUsuario.currentIndex()
        usuario = self.enviosUsuario[indiceUsuario]

        if indiceUsuario > 0:

            indexSel = []
            for c in range(0, self.dlg.tablaMazPred.rowCount()):
                indexSel.append(c)

            if len(indexSel) >0:

                listaAEnviar = []
                for index in indexSel:
                    cveManzana = str(self.dlg.tablaMazPred.item(index, 0).text())
                    cvePredioMedia = str(self.dlg.tablaMazPred.item(index, 2).text())
                    cveCatCompleta = cveManzana + cvePredioMedia
                    
                    objeto = {}
                    objeto['cveUsuario'] = usuario
                    objeto['cveCatastral'] = cveCatCompleta

                    listaAEnviar.append(objeto)

                listaAEnviar = json.dumps(listaAEnviar)

                try:
                    headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}
                    respuesta = requests.post(self.CFG.urlAsigPadAgregar, headers = headers, data=listaAEnviar)

                    if respuesta.status_code == 200:
                        
                        self.UTI.mostrarAlerta("Asignacion completa", QMessageBox().Information, "Asignacion de padron")
                        self.vaciarTabla(self.dlg.tablaMazPred)
                        keysDer = list(self.clavesDer.keys())
                        for k in keysDer:
                            self.clavesDer[k] = []
                        self.actualizarTablas()

                    else:
                        self.UTI.mostrarAlerta("Error de servidor ACAMP1", QMessageBox().Critical, "Asignacion de padron")

                except requests.exceptions.RequestException:
                    self.UTI.mostrarAlerta("Error de servidor ACAMP", QMessageBox().Critical, "Asignacion de padron")

            else:
                self.UTI.mostrarAlerta("No se han agregado asignaciones", QMessageBox().Critical, "Asignacion de padron")

        else:
            self.UTI.mostrarAlerta("Debes seleccionar un usuario", QMessageBox().Critical, "Asignacion de padron")

#---------------------------------------------------------------------------------------------------

    def llamarLiberar(self):
        indiceUsuario = self.dlg.cmbUsuario.currentIndex()
        
        if indiceUsuario > 0:
            self.VentanaLiberacion.run()
        else:
            self.UTI.mostrarAlerta("Debes seleccionar un usuario", QMessageBox().Critical, "Asignacion de padron")

#-----------------------------------------------------------------------------------------------------

    def llenarUsuarios(self):

        self.dlg.cmbUsuario.clear()

        try:
            headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}
            respuesta = requests.get(self.CFG.urlObtenerUsuarios, headers = headers)
        except requests.exceptions.RequestException:
            self.UTI.mostrarAlerta("Error de servidor ACAUSU1", QMessageBox().Critical, "Cargar Manzanas")
            print('ERROR: USU000')

        lenJson = len(list(respuesta.json()))

        if lenJson > 0:
            listaTemp = ['--Selecciona--']
            self.enviosUsuario = ['-']
            for dato in respuesta.json():
                listaTemp.append(str(dato['firstName'] )+ ' ' + str(dato['lastName']))
                self.enviosUsuario.append(dato['login'])
            modeloTemp = QStandardItemModel()
            for i,word in enumerate( listaTemp ):   
                
                item = QStandardItem(word)
                modeloTemp.setItem(i, 0, item)

            self.UTI.extenderCombo(self.dlg.cmbUsuario, self.completarUsuario, modeloTemp)
            self.dlg.cmbUsuario.model().item(0).setEnabled(False)

#------------------------------------------------------------

    def resetar(self):
        self.vaciarTabla(self.dlg.tablaClaves)
        self.vaciarTabla(self.dlg.tablaMazPred)
        self.dlg.cmbManzana.clear()
        self.dlg.cmbSector.clear()
        self.dlg.cmbManzana.setEnabled(False)
        self.dlg.cmbSector.setEnabled(False)
        self.clavesIzq = []
        self.clavesDer = {}
        self.manzanaCargada = -1
        self.localidadCargado = -1
        self.sectorCargado = -1