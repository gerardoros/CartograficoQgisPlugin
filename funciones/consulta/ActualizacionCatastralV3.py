# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ActualizacionCatastralV3
                                 A QGIS plugin
 ActualizacionCatastralV3
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-07-02
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Charro
        email                : ActualizacionCatastralV3
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QRectF
from PyQt5.QtGui import QIcon, QFont
from PyQt5.QtWidgets import QAction

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .ActualizacionCatastralV3_dialog import ActualizacionCatastralV3Dialog
import os.path

from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, Qt, QSettings, QSize
from PyQt5.QtGui import QIcon, QColor, QCursor, QPixmap, QStandardItemModel
from PyQt5.QtWidgets import QAction, QMessageBox, QTableWidgetItem, QListView, QCompleter
from PyQt5 import QtWidgets
# Initialize Qt resources from file resources.py
from qgis.core import *
from qgis.utils import iface
from qgis.gui import QgsLayerTreeView, QgsVertexMarker
from PyQt5 import QtGui
# Import the code for the DockWidget
import os, json, requests, datetime, qgis.core
from datetime import datetime as dt
from osgeo import ogr, osr
from .Cedula_MainWindow import CedulaMainWindow

class ActualizacionCatastralV3:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        
        self.iface = iface
         
        self.CFG = None
        self.UTI = None
        self.DFS = None
        self.DBJ = None
        self.ELM = None
        self.DFS = None
        self.TPG = None

        # variable que almacenara la capa de referencia que se encuentre en edicion
        self.capaEnEdicion = ''

        self.pluginIsActive = False
        self.dockwidget = None
        self.dockwidget = ActualizacionCatastralV3Dialog(parent = iface.mainWindow())
        #self.dockwidget.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)

        self.dockwidget.labelStatusEdicion.setText('')
        self.dockwidget.labelCapaEdicion.setText('')

        self.dockwidget.botonCargar.clicked.connect(self.pintarCapas)
        self.dockwidget.botonCargarReferencia.clicked.connect(self.intermediarioReferencia)
        self.dockwidget.btnLimpiar.clicked.connect(self.limpiarReferencias)
        self.dockwidget.btnLimpiaArea.clicked.connect(self.limpiaArea)


        self.dockwidget.botonEditar.clicked.connect(self.actualizarFeature)
        self.dockwidget.botonActualizarRef.clicked.connect(self.actualizarFeatureRef)
        self.dockwidget.botonCancelarReferencia.clicked.connect(self.rollbackCapa)
        # self.dockwidget.comboLocalidad.currentIndexChanged.connect(self.obtenerSectoresPorLocalidad)
        self.dockwidget.comboSector.currentIndexChanged.connect(self.obtenerManzanasPorSector)
        self.dockwidget.comboManzana.currentIndexChanged.connect(self.obtenerIdManzana)
        self.dockwidget.botonActivarEdicion.clicked.connect(self.activarEdicion)
        self.dockwidget.botonActualizarServiciosCalles.clicked.connect(self.actualizarServiciosCalles)

        self.dockwidget.btnPlanoManzanero.clicked.connect(self.event_planoMza)


        '''
        view = QListView()
        view.setFixedHeight(200)
        self.dockwidget.comboSector.setView(view)
        '''
        '''
        m = QStandardItemModel()

        p = QCompleter(self.dockwidget.comboSector)
        p.setMaxVisibleItems(20)

        p.setPopup( p.popup() )
        self.dockwidget.comboSector.setModel(m)
        self.dockwidget.comboSector.setCompleter(p)
        '''


        self.diccServiciosCalle = {}

        self.capaEnEdicion = ''
        QSettings().setValue('capaRefEdicion', 'None')
        self.manzanaPrincipal = None
        self.tablasReferencias = {
        'Estado' : 'e_estado',
        'Region Catastral' : 'e_region_carto',
        'Municipios' : 'e_municipio',
        'Secciones' : 'e_seccion',		
        'Localidades' : 'e_localidad',
        'Sectores' : 'e_sector',
        'Manzanas' : 'e_manzana',
        'Predios' : 'e_predio',
        'Calles' : 'vw_calle',
        'Colonias' : 'e_colonia',
        'Codigo Postal' : 'e_cp',
        'Zona Uno' : 'e_zona_uno',
        'Zona Dos' : 'e_zona_dos',
        'Area de Valor' : 'e_area_valor'
        }

        # -- evento boton de abrir cedula --
        self.dockwidget.btnAbrirCedula.setIcon(QtGui.QIcon('add.png'))
        self.dockwidget.btnAbrirCedula.clicked.connect(self.abrirCedula)

        # -- evento boton de cancelar apertura de cedula --
        self.dockwidget.btnCancelAperCedula.clicked.connect(self.cancelarCedula)
        self.canvas = iface.mapCanvas()
        self.cursorRedondo = QCursor(QPixmap(["16 16 3 1",
                                "      c None",
                                ".     c #FF0000",
                                "+     c #FFFFFF",
                                "                ",
                                "       +.+      ",
                                "      ++.++     ",
                                "     +.....+    ",
                                "    +.     .+   ",
                                "   +.   .   .+  ",
                                "  +.    .    .+ ",
                                " ++.    .    .++",
                                " ... ...+... ...",
                                " ++.    .    .++",
                                "  +.    .    .+ ",
                                "   +.   .   .+  ",
                                "   ++.     .+   ",
                                "    ++.....+    ",
                                "      ++.++     ",
                                "       +.+      "]))

        # --  dise√±o del cursor --
        self.abrePredio = False
        # -- lista -- 
        self.dockwidget.lista = {}
        self.actions = []

        # listas edicion de capas de referencia
        self.featuresId = []
        
        #Marcadores
        self.verticesManzana = []
        self.verticesPredio = []
        self.verticesConst = []

        self.dockwidget.btnActMarc.clicked.connect(self.actualizarMarcadores)

        self.dockwidget.tablaServiciosCalles.setEditTriggers(QtWidgets.QTableWidget.NoEditTriggers)

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ActualizacionCatastralV3', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/ActualizacionCatastralV3/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'ActualizacionCatastralV3'),
            callback=self.run,
            parent=self.iface.mainWindow())


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&ActualizacionCatastralV3'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar


    def run(self):
        """Run method that performs all the real work"""
        # show the dialog

        adelante = False
        # muestra siempre la primer tab
        self.dockwidget.tabWidget.setCurrentIndex(0)

        self.obtenerXCapas()

        if QSettings().value('integrando') == 'True':
            
            mensaje = "Tienes cambios de carga masiva que aun no se han integrado, si procedes se perderan los cambios..."
            respuesta = QMessageBox.question(iface.mainWindow(), "Advertencia", mensaje, QMessageBox.Yes, QMessageBox.No)
            
            
            if respuesta == QMessageBox.Yes:
                QSettings().setValue('integrando', 'False')

                self.vaciarCapa(self.xManzana)
                self.vaciarCapa(self.xPredGeom)
                self.vaciarCapa(self.xPredNum)
                self.vaciarCapa(self.xConst)
                self.vaciarCapa(self.xHoriGeom)
                self.vaciarCapa(self.xHoriNum)
                self.vaciarCapa(self.xVert)
                self.vaciarCapa(self.xCvesVert)
                adelante = True
        else:
            adelante = True
        

        if adelante:

            self.CMS.dlg.close()
            self.dockwidget.show()
            
            #self.UTI.strechtTabla(self.dockwidget.tablaEdicion)
            self.UTI.strechtTabla(self.dockwidget.tablaEdicionRef)

            if self.capasCompletas():

                if not self.pluginIsActive:
                    self.pluginIsActive = True

                    if self.dockwidget == None:

                        self.dockwidget = ActualizacionCatastralV3Dialog()


                    self.cuerpo = {"incluirGeom": "true", "pagina": None, "bbox": "false", "pin": "false", "geomWKT": None, "epsg": None, "properties": None, "epsgGeomWKT": None, "itemsPagina": None, "nombre": "x"}
                    self.headers = {'Content-Type': 'application/json'}
                    self.payload = json.dumps(self.cuerpo)

                    self.dockwidget.comboSector.clear()
                    #self.dockwidget.comboLocalidad.clear()
                    self.dockwidget.comboManzana.clear()

                    #Inicializacionde IdManzana
                    self.idManzana = ' '

                    #Modo desarrollor
                    self.modoDesarrollo = False
                    self.cargaRapida = True
                    #01001001020004054011
                    #01001001020004027003
                    #01001001020004063010

                    if self.capaEnEdicion != '':

                        self.dockwidget.comboCapasEdicion.setEnabled(False)
                        self.dockwidget.botonActivarEdicion.setEnabled(False)
                        self.dockwidget.botonActualizarRef.setEnabled(True)
                        self.dockwidget.botonCancelarReferencia.setEnabled(True)

                    else:

                        self.dockwidget.comboCapasEdicion.setEnabled(True)
                        self.dockwidget.botonActivarEdicion.setEnabled(True)
                        self.dockwidget.botonActualizarRef.setEnabled(False)
                        self.dockwidget.botonCancelarReferencia.setEnabled(False)

                    if self.capaEnEdicion == self.obtenerIdCapa('Calles'):
                        self.dockwidget.tablaServiciosCalles.setVisible(True)
                        self.dockwidget.botonActualizarServiciosCalles.setVisible(True)
                        self.dockwidget.tituloServiciosCalles.setVisible(True)
                        self.UTI.strechtTabla(self.dockwidget.tablaServiciosCalles)
                    else:
                        self.dockwidget.tablaServiciosCalles.setVisible(False)
                        self.dockwidget.botonActualizarServiciosCalles.setVisible(False)
                        self.dockwidget.tituloServiciosCalles.setVisible(False)

                    #Acciones iniciales
                    if self.modoDesarrollo:
                        self.obtenerIdManzana()

                    else:
                        try:
                            self.obtenerSectoresPorMunicipio()

                        except:
                            self.UTI.mostrarAlerta("Error al cargar Sectores\nError de servidor loc1", QMessageBox().Information, "Cargar Localidades")

                    #Asignar eventos de cambio de seleccion
                    
                    self.xManzana.selectionChanged.connect(self.cargarTablita)
                    self.xPredGeom.selectionChanged.connect(self.cargarTablita)
                    self.xPredNum.selectionChanged.connect(self.cargarTablita)
                    self.xConst.selectionChanged.connect(self.cargarTablita)
                    self.xHoriGeom.selectionChanged.connect(self.cargarTablita)
                    self.xHoriNum.selectionChanged.connect(self.cargarTablita)
                    self.xVert.selectionChanged.connect(self.cargarTablita)
                    self.xCvesVert.selectionChanged.connect(self.cargarTablita)

                    self.llenarComboReferencias()
                    self.dockwidget.show()
                    
            else:
                self.UTI.mostrarAlerta('No existen las capas necesarias para la consulta de manzanas', QMessageBox().Critical, 'Consulta de manzanas')
                return
            result = self.dockwidget.exec_()
            # See if OK was pressed
            if result:
                # Do something useful here - delete the line containing pass and
                # substitute with your code.
                pass

    #------------------------------------------------------------------------

    
#######################################################################################################################
    
    #validar posicion valida de combo, si hay registros en los combos de localidad, sector y manzana
    def validarCombox(self):
        #return (self.dockwidget.combos.count() > 0 and self.dockwidget.comboSector.count() > 0 and self.dockwidget.comboManzana.count()) or self.modoDesarrollo
        return (self.dockwidget.comboSector.count() > 0 and self.dockwidget.comboManzana.count()) or self.modoDesarrollo

##########################################################################
    def obtenerIdManzana(self):
        
        
        #Obtener el identificador de la manzana
        if self.modoDesarrollo:
           
            #self.idManzana = '01 001 001 02 0004 016 031' #Esta es la chida
            #self.idManzana = '01 001 001 02 0004 026 039' #Cortita y chiquita
            #self.idManzana = '01 001 001 02 0004 026 040' #Cortita y chiquita
            #self.idManzana = '01 001 001 02 0004 060 004' 
                             #01001001020  4026040
            #self.idManzana = '01001001020004060004'  #La larga
            #self.idManzana = '01001001020004020001'
            #self.idManzana = '01001001020004020001'
            self.idManzana = '01001001020004015001'
            
            #01001001020004026039
            #01001001020  4026039

            #self.idManzana = '01001001020004017005' #esta es la mala krnal
            #self.idManzana =  '010010010204050001' #Esta calamos guardado
            #self.idManzana = '01001001020004026040'
            #self.idManzana = '01001001020004021016'
            

        else:
            index = self.dockwidget.comboManzana.currentIndex()
            self.idManzana = self.dockwidget.comboManzana.itemData(index)




        
########################################################################################################################

    def obtenerMunicipios(self):

        self.cve_cat_len = 16

        self.dockwidget.comboLocalidad.clear()

        try:
            headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}
            respuesta = requests.get(self.CFG.urlMunicipios, headers = headers)
        except requests.exceptions.RequestException:
            self.UTI.mostrarAlerta("Error de servidor loc2", QMessageBox().Critical, "Cargar Municipios")
            print('ERROR: MUN0000')

        lenJson = len(list(respuesta.json()))

        if lenJson > 0:
            for localidad in respuesta.json():
                self.dockwidget.comboLocalidad.addItem(str(localidad['label']) + " " + localidad['other'], str(localidad['value']) )
        else:
            self.UTI.mostrarAlerta("No existen Municipios registrados", QMessageBox().Information, "Cargar Municipios")




    #Llenar primer combo
    def obtenerLocalidades(self):

        self.cve_cat_len = 25

        self.dockwidget.comboLocalidad.clear()

        try:
            headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}
            respuesta = requests.get(self.CFG.urlLocalidades, headers = headers)
        except requests.exceptions.RequestException:
            self.UTI.mostrarAlerta("Error de servidor loc2", QMessageBox().Critical, "Cargar Localidades")
            print('ERROR: LOC000')

        lenJson = len(list(respuesta.json()))

        if lenJson > 0:
            for localidad in respuesta.json():
                self.dockwidget.comboLocalidad.addItem(str(localidad['label']) + " " + localidad['other'], str(localidad['value']) )
        else:
            self.UTI.mostrarAlerta("No existen localidades registradas", QMessageBox().Information, "Cargar Localidades")

#################################################################################################################################

    def obtenerSectoresPorLocalidad(self):

        if self.dockwidget.comboLocalidad.count() > 0:

            index = self.dockwidget.comboLocalidad.currentIndex()
            idSector = self.dockwidget.comboLocalidad.itemData(index)
            
            self.dockwidget.comboSector.clear()

            #Si es una clave de 16, buscaremos sectores por municipio, de lo contrario sera por localidad
            url = self.CFG.urlSectoresMuni if self.cve_cat_len == 16 else self.CFG.urlSectores

            try:
                headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}
                respuesta = requests.get(url + idSector + '/sector/', headers = headers)
            except requests.exceptions.RequestException:
                self.UTI.mostrarAlerta("Error de servidor sec1", QMessageBox().Critical, "Cargar Sectores")
                print('ERROR: SEC000')

            lenJson = len(list(respuesta.json()))

            if lenJson > 0:

                for sector in respuesta.json():

                    self.dockwidget.comboSector.addItem(sector['label'], sector['value']) #Cambiar value por label
            #else:
            #    self.UTI.mostrarAlerta("No existen sectores en la localidad", QMessageBox().Information, "Cargar Sectores")
            

    # cambio a clave de 16
    def obtenerSectoresPorMunicipio(self):

        id = '1' # hardcodeado el identificador del municipio
        self.dockwidget.comboSector.clear()

        url = self.CFG.urlSectoresMuni

        try:
            headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}
            respuesta = requests.get(url + id + '/sector/', headers = headers)
        except requests.exceptions.RequestException:
            self.UTI.mostrarAlerta("Error de servidor sec1", QMessageBox().Critical, "Cargar Sectores")
            print('ERROR: SEC000')

        lenJson = len(list(respuesta.json()))

        if lenJson > 0:
            for sector in respuesta.json():
                self.dockwidget.comboSector.addItem(sector['label'], sector['value']) #Cambiar value por label
            

################################################################################################################################

    def llenarComboReferencias(self):
        self.dockwidget.comboCapaReferencia.clear()
        #self.dockwidget.comboCapaReferencia.addItem('Estado', 'e_estado')
        #self.dockwidget.comboCapaReferencia.addItem('Region Catastral', 'e_region_carto')
        self.dockwidget.comboCapaReferencia.addItem('Municipios', 'e_municipio')
        #self.dockwidget.comboCapaReferencia.addItem('Secciones', 'e_seccion')
        #self.dockwidget.comboCapaReferencia.addItem('Localidades', 'e_localidad')
        self.dockwidget.comboCapaReferencia.addItem('Sectores', 'e_sector')
        self.dockwidget.comboCapaReferencia.addItem('Manzanas', 'e_manzana')
        self.dockwidget.comboCapaReferencia.addItem('Predios', 'e_predio')
        self.dockwidget.comboCapaReferencia.addItem('Calles', 'vw_calle')
        self.dockwidget.comboCapaReferencia.addItem('Colonias', 'e_colonia')
        self.dockwidget.comboCapaReferencia.addItem('Codigo Postal', 'e_cp')
        #self.dockwidget.comboCapaReferencia.addItem('Zona Uno', 'e_zona_uno')
        #self.dockwidget.comboCapaReferencia.addItem('Zona Dos', 'e_zona_dos')
        self.dockwidget.comboCapaReferencia.addItem('Area de Valor', 'e_area_valor')


#################################################################################################################################
    #Llenar tercer combo
    def obtenerManzanasPorSector(self):
    
        if self.dockwidget.comboSector.count() > 0:

            index = self.dockwidget.comboSector.currentIndex()
            idSector = self.dockwidget.comboSector.itemData(index)

            self.dockwidget.comboManzana.clear()

            try:
                headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}
                respuesta = requests.get(self.CFG.urlManzanas + idSector + '/manzana/', headers = headers)
            except requests.exceptions.RequestException:
                self.UTI.mostrarAlerta("Error de servidor man1sec", QMessageBox().Critical, "Cargar Manzanas")
                print('ERROR: MAN000')

            lenJson = len(list(respuesta.json()))

            if lenJson > 0:
                for manzana in respuesta.json():
                    self.dockwidget.comboManzana.addItem(manzana['label'], manzana['other'])#Cambiar other por label
            #else:
            #    self.UTI.mostrarAlerta("No existen manzanas en el sector", QMessageBox().Information, "Cargar Manzanas")

#####################################################################################################

    def intermediarioReferencia(self):
        nameCapa = self.dockwidget.comboCapaReferencia.currentText()
        
        try:
            bound = self.obtenerBoundingBox().asWkt()
        except:
            self.UTI.mostrarAlerta('No se ha cargado ninguna Manzana', QMessageBox().Critical, 'Cargar referencia')
            return

        if self.dockwidget.checkTodasGeom.isChecked():
            bound = None

        # si se trata de predios tambien se cargan las contrucciones
        if nameCapa.lower() == 'predios':
            self.pintarCapasReferencia("Construcciones", bound, False)
            self.pintarCapasReferencia(nameCapa, bound, False)
        else:
            self.pintarCapasReferencia(nameCapa, bound, False)


    def limpiarReferencias(self):

        # se preparan las capas de referencia para borrarlas
        lista = []
        lista.append(QSettings().value('xAreaValor'))
        lista.append(QSettings().value('xZonaUno'))
        lista.append(QSettings().value('xCP'))
        lista.append(QSettings().value('xZonaDos'))
        lista.append(QSettings().value('xColonia'))
        lista.append(QSettings().value('xCalle'))
        lista.append(QSettings().value('xSector'))
        lista.append(QSettings().value('xLocal'))
        lista.append(QSettings().value('xSeccion'))
        lista.append(QSettings().value('xMunicipio'))
        lista.append(QSettings().value('xRegion'))
        lista.append(QSettings().value('xEstado'))
        lista.append(QSettings().value('xManzanasRef'))
        lista.append(QSettings().value('xPredRef'))
        lista.append(QSettings().value('xConstRef'))

        root = QgsProject.instance().layerTreeRoot()
        # se obtienen los grupos a los que pertenecen cada una de esas capas
        listaGpo = []

        for l in lista:
            if l != 'None' and l is not None:
                tree_layer = root.findLayer(l)
                if tree_layer is not None:
                    listaGpo.append(tree_layer.parent().name())

            # validar que no se borre si se tiene en la edicion
            # borrar las capas de referencia validando lo de arriba
            if self.capaEnEdicion != l:
                QgsProject.instance().removeMapLayers( [l] )

        # se quitan los grupos duplicados
        listaGpo = list(dict.fromkeys(listaGpo))
        
        # se borran los grupos
        for l in listaGpo:
            if l != 'referencia' and l != 'edicion':
                group = root.findGroup(l)
                root.removeChildNode(group)

        # se actualiza el canvas 
        iface.mapCanvas().refresh()

    def limpiarConsulta(self):

        # se preparan las capas de referencia para borrarlas
        lista = []
        lista.append(QSettings().value('xManzana'))
        lista.append(QSettings().value('xPredGeom'))
        lista.append(QSettings().value('xPredNum'))
        lista.append(QSettings().value('xConst'))
        lista.append(QSettings().value('xHoriGeom'))
        lista.append(QSettings().value('xHoriNum'))
        lista.append(QSettings().value('xVert'))
        lista.append(QSettings().value('xCvesVert'))
        #lista.append(QSettings().value('xAreasInscritas'))

        root = QgsProject.instance().layerTreeRoot()
        # se obtienen los grupos a los que pertenecen cada una de esas capas
        listaGpo = []

        for l in lista:
            if l != 'None' and l is not None:
                tree_layer = root.findLayer(l)
                if tree_layer is not None:
                    listaGpo.append(tree_layer.parent().name())

            # elimina las capas de consulta
            QgsProject.instance().removeMapLayers( [l] )

        # se quitan los grupos duplicados
        listaGpo = list(dict.fromkeys(listaGpo))

        # se borran los grupos
        for l in listaGpo:
            group = root.findGroup(l)
            root.removeChildNode(group)

        # se actualiza el canvas 
        iface.mapCanvas().refresh()

    def limpiaArea(self):
        mensaje = "Se limpiar√° el √°rea de trabajo. Cualquier cambio no guardado se perder√°, ¬øest√°s seguro de continuar?"
        respuesta = QMessageBox.question(iface.mainWindow(), "Advertencia", mensaje, QMessageBox.Yes, QMessageBox.No)
        
        if respuesta == QMessageBox.No:
            return

        root = QgsProject.instance().layerTreeRoot()

        # se limpian las referencias
        self.limpiarReferencias()

        # limpiar capas de consulta
        self.limpiarConsulta()

        # se limpian las demas capas agregadas
        group = root.findGroup('ERRORES DE TOPOLOGIA')
        if not group is None:
            group.removeAllChildren()
            root.removeChildNode(group)

        # elimina todos los grupos restantes
        root = QgsProject.instance().layerTreeRoot()
        l = []
        l.append('referencia')
        l.append('edicion')
        l.append('consulta')

        for node in root.children():
            if node.name() in l:
                g = root.findGroup(node.name())
                root.removeChildNode(g)


##############################################################################################

#####################################################################################################

    def obtenerBoundingBox(self):
        
        self.manzanaPrincipal = self.xManzana
        xManzana = QgsProject.instance().mapLayer(self.obtenerIdCapa('manzana'))

        if xManzana is None:
            return

        listaManzanas = list(self.manzanaPrincipal.getFeatures())
        geometria = QgsGeometry()

        rango = len(listaManzanas)
        if rango == 0:
            return None

        geometria = listaManzanas[0].geometry()

        for i in range(0, rango):
            geometria = geometria.combine(listaManzanas[i].geometry())

        geoTemp = (QgsGeometry.fromWkt(geometria.boundingBox().asWktPolygon())).buffer(10, 0)

        return geoTemp



#####################################################################################################

    #Pintar todas las capas
    def pintarCapas(self):

        # inicializa la lista de geometrias eliminadas
        QSettings().setValue('listaEliminada', [])

        # obtiene la instancia del arbol de capas
        root = QgsProject.instance().layerTreeRoot()

        # elimina las capas de los errores de topologia
        group = root.findGroup('ERRORES DE TOPOLOGIA')
        if not group is None:
            for child in group.children():
                dump = child.dump()
                id = dump.split("=")[-1].strip()
                QgsProject.instance().removeMapLayer(id)
            root.removeChildNode(group)

        # obtiene los identificadores de capas, carga las capas y asigna eventos
        self.obtenerXCapas()

        root = QgsProject.instance().layerTreeRoot()
        group = root.findGroup('referencia')

        # valida si los combos contienen informacion
        if self.validarCombox():

            self.vaciarCapa(self.xManzana)
            self.vaciarCapa(self.xPredGeom)
            self.vaciarCapa(self.xPredNum)
            self.vaciarCapa(self.xConst)
            self.vaciarCapa(self.xHoriGeom)
            self.vaciarCapa(self.xHoriNum)
            self.vaciarCapa(self.xVert)
            self.vaciarCapa(self.xCvesVert)

            if self.cargaRapida:
                if not self.pintarUnaCapa(self.xManzana):
                    return
                self.zoomManzana()
                
                if not self.pintarUnaCapa(self.xPredGeom):
                    return

                if not self.pintarNum(self.xPredNum):
                    return
                
                if not self.pintarUnaCapa(self.xConst):
                    return

                if not self.pintarUnaCapa(self.xHoriGeom):
                    return

                if not self.pintarNum(self.xHoriNum):
                    return
                
                if not self.pintarUnaCapa(self.xVert):
                    return
                
                if not self.pintarUnaCapa(self.xCvesVert):
                    return
            
                

            else:
                if not self.pintarUnaCapa(self.xManzana):
                    return
                self.zoomManzana()
                
                if not self.pintarUnaCapa(self.xPredGeom):
                    return

                if not self.pintarNum(self.xPredNum):
                    return
                
                if not self.pintarUnaCapa(self.xConst):
                    return
                
                if not self.pintarUnaCapa(self.xHoriGeom):
                    return

                if not self.pintarNum(self.xHoriNum):
                    return

                if not self.pintarUnaCapa(self.xVert):
                    return
                
                if not self.pintarUnaCapa(self.xCvesVert):
                    return
            
            print ("Capas cargadas con exito")

        else:
            self.UTI.mostrarAlerta('No se han seleccionado manzanas para cargar', QMessageBox.Critical, 'Capas de consulta')

##############################################################################################################

    def pintarCapasCampo(self):
        self.vaciarCapa(self.xManzana)
        self.vaciarCapa(self.xPredGeom)
        self.vaciarCapa(self.xPredNum)
        self.vaciarCapa(self.xConst)
        self.vaciarCapa(self.xHoriGeom)
        self.vaciarCapa(self.xHoriNum)
        self.vaciarCapa(self.xVert)
        self.vaciarCapa(self.xCvesVert)

        
        if not self.pintarUnaCapa(self.xManzana):
            return
        self.zoomManzana()
        
        if not self.pintarUnaCapa(self.xPredGeom):
            return

        if not self.pintarNum(self.xPredNum):
            return
        
        if not self.pintarUnaCapa(self.xHoriGeom):
            return

        if not self.pintarNum(self.xHoriNum):
            return

        if not self.pintarUnaCapa(self.xVert):
            return
        
        if not self.pintarUnaCapa(self.xCvesVert):
            return
        
        print ("Capas cargadas con exito")

########################################################################################################

    def pintarUnaCapa(self, mem_layer):
        
        nombreCapa = mem_layer.name()
    

        if mem_layer == None:
            self.UTI.mostrarAlerta('No existe la capa ' + str(nombreCapa), QMessageBox().Critical, 'Cargar capas')
            return False
        
        data = self.obtenerAPintar(mem_layer.id())
        '''
        print(nombreCapa)
        print(data)
        print(self.idManzana)
        '''

        type(data)
        srid = QSettings().value("srid")
        inSpatialRef = osr.SpatialReference()
        inSpatialRef.ImportFromEPSG(int(srid))
        outSpatialRef = osr.SpatialReference()
        outSpatialRef.ImportFromEPSG(int(srid))
        coordTrans = osr.CoordinateTransformation(inSpatialRef, outSpatialRef)
        if not bool(data):
            self.UTI.mostrarAlerta("Error de servidor pintcap", QMessageBox().Critical, "Cargar capa de consulta")
            print('ERROR: CAP000')

        #Obtenemos todos los atributos del JSON
        if data['features'] == []:
            return True
        
        varKeys = data['features'][0]['properties']

        keys = list(varKeys.keys())
        properties = []
        geoms = []

        for feature in data['features']:

            geom = feature['geometry']
            
            property = feature['properties']
            geom = json.dumps(geom)
            geometry = ogr.CreateGeometryFromJson(geom)
            geometry.Transform(coordTrans)
            geoms.append(geometry.ExportToWkt())
            l = []
            for i in range(0, len(keys)):
                l.append(property[keys[i]])
            properties.append(l)

        prov = mem_layer.dataProvider()
        feats = [ QgsFeature() for i in range(len(geoms)) ]

        for i, feat in enumerate(feats):
            feat.setAttributes(properties[i])
            feat.setGeometry(QgsGeometry.fromWkt(geoms[i]))

        prov.addFeatures(feats)

        if nombreCapa == 'predios.geom':
            self.cargarPrediosEnComboDividir(feats)

        mem_layer.triggerRepaint()
        return True

####################################################################################################

    def pintarNum(self, mem_layer):

        nombreCapa = mem_layer.name()
    
        if mem_layer == None:
            self.UTI.mostrarAlerta('No existe la capa ' + str(nombreCapa), QMessageBox().Critical, 'Cargar capas')
            return False

        data = self.obtenerAPintar(mem_layer.id())

        etiquetaField = ""
        colorCapa = ""
        if mem_layer.id() == self.obtenerIdCapa("predios.num"):
            etiquetaField = "numExt"
            colorCapa = QColor(0,255,0)
        elif mem_layer.id() == self.obtenerIdCapa("horizontales.num"):
            etiquetaField = "num_ofi"
            colorCapa = QColor(198,140,33)

        type(data)
        srid = QSettings().value("srid")
        inSpatialRef = osr.SpatialReference()
        inSpatialRef.ImportFromEPSG(int(srid))
        outSpatialRef = osr.SpatialReference()
        outSpatialRef.ImportFromEPSG(int(srid))
        coordTrans = osr.CoordinateTransformation(inSpatialRef, outSpatialRef)
        if not bool(data):
            return True
            

        
        
        #Obtenemos todos los atributos del JSON
        polys = []
        listNum = []

        for feature in data:
            wkt = feature['geomNum']
            listNum.append(feature[etiquetaField])
            gem = QgsGeometry.fromWkt(wkt)
            polys.append(gem)

        mem_layer.startEditing()

        prov = mem_layer.dataProvider()
        feats = [ QgsFeature() for i in range(len(polys)) ]

        for i, feat in enumerate(feats):  
            feat.setGeometry(polys[i])
            prov.addFeature(feat)
            #feat[etiquetaField] = listNum[i]
            #mem_layer.updateFeature(feat)
            mem_layer.changeAttributeValue(feat.id(), 0, listNum[i])
            
        mem_layer.commitChanges()

        settings = QgsPalLayerSettings()
        settings.fieldName = etiquetaField
        settings.enabled = True
        settings.isExpression = False
        
        settings.centroidWhole = True

        textFormat = QgsTextFormat()
        textFormat.setColor(colorCapa)
        textFormat.setSize(8)
        textFormat.setNamedStyle('Bold')

        settings.setFormat(textFormat)

        #settings.placement= QgsPalLayerSettings.OverPoint
        labeling = QgsVectorLayerSimpleLabeling(settings)

        mem_layer.setLabeling(labeling)
        mem_layer.setLabelsEnabled(True)

        mem_layer.triggerRepaint()

        return True
        
#####################################################################################################

    def vaciarCapa(self, mem_layer):

        if mem_layer == None:
            return

        mem_layer.setReadOnly(False)
        #Obtenemos los fields antes de eliminar las features
        inFields = mem_layer.dataProvider().fields()
        #Habilitamos opcion de editado
        mem_layer.startEditing()
        #Iteramos para eliminar Features
        for f in mem_layer.getFeatures():
            mem_layer.deleteFeature(f.id())
        
        #Reasignamos los fields al VectorLayer
        mem_layer.dataProvider().addAttributes(inFields.toList())
        #Guardamos los cambios
        mem_layer.setReadOnly(True)
        mem_layer.commitChanges()

###################################################################################

    def zoomManzana(self):
    
        mem_layer = self.xManzana

        if mem_layer == None:
            return

        listaManzanas = list(mem_layer.getFeatures())
        geometria = QgsGeometry()

        rango = len(listaManzanas)

        if rango == 0:
            return

        geometria = listaManzanas[0].geometry()

        for i in range(0, rango):
            geometria = geometria.combine(listaManzanas[i].geometry())

        bbox = geometria.boundingBox()
        iface.mapCanvas().setExtent(bbox)
        iface.mapCanvas().refresh()

############################################################################################

    
    def esCapaReferencia(self, idCapa):

        if idCapa == self.obtenerIdCapa('Area de Valor'):
            return True
        elif idCapa == self.obtenerIdCapa('Zona Uno'):
            return True
        elif idCapa == self.obtenerIdCapa('Zona Dos'):
            return True
        elif idCapa == self.obtenerIdCapa('Codigo Postal'):
            return True
        elif idCapa == self.obtenerIdCapa('Colonias'):
            return True
        elif idCapa == self.obtenerIdCapa('Calles'):
            return True
        elif idCapa == self.obtenerIdCapa('Sectores'):
            return True
        elif idCapa == self.obtenerIdCapa('Localidades'):
            return True
        elif idCapa == self.obtenerIdCapa('Secciones'):
            return True
        elif idCapa == self.obtenerIdCapa('Municipios'):
            return True
        elif idCapa == self.obtenerIdCapa('Region Catastral'):
            return True
        elif idCapa == self.obtenerIdCapa('Estado'):
            return True
        
        else:
            return False

###############################################################################################

    def obtenerAPintar(self, idCapa):

        url = ' '
        if self.traducirIdCapa(idCapa) == 'manzana':
            url = self.CFG.urlConsultaManzana
        elif self.traducirIdCapa(idCapa) == 'predios.geom':
            url = self.CFG.urlConsultaPrediosGeom
        elif self.traducirIdCapa(idCapa) == 'predios.num':
            url = self.CFG.urlConsultaPrediosNum
        elif self.traducirIdCapa(idCapa) == 'construcciones':
            url = self.CFG.urlConsultaConstrucciones
        elif self.traducirIdCapa(idCapa) == 'horizontales.geom':
            url = self.CFG.urlConsultaHorizontalesGeom
        elif self.traducirIdCapa(idCapa) == 'horizontales.num':
            url = self.CFG.urlConsultaHorizontalesNum
        elif self.traducirIdCapa(idCapa) == 'verticales':
            url = self.CFG.urlConsultaVerticales
        elif self.traducirIdCapa(idCapa) == 'cves_verticales':
            url = self.CFG.urlConsultaClavesV

        #idManzana = self.dockwidget.comboManzana.currentText()
        try:
            headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}
            if self.traducirIdCapa(idCapa) == 'predios.num' or self.traducirIdCapa(idCapa) == 'horizontales.num':
                response = requests.get(url + self.idManzana, headers = headers)
            else:
                response = requests.post(url + self.idManzana, headers = headers, data = self.payload)

        except requests.exceptions.RequestException:
            self.UTI.mostrarAlerta("Error de servidor obtenerPintar", QMessageBox().Critical, "Error de servidor")
            print('ERROR OAP000')
            return
        data = ""
        if response.status_code == 200:
            
            data = response.content

        else:
            self.UTI.mostrarAlerta('Error en peticion:\n' + response.text, QMessageBox().Critical, "Cargar capa")
            print('ERROR: CAP001')

        return json.loads(data.decode('utf-8'))


        #Metodo que crea un elemento QMessageBox
    
#########################################################################################################
    
    def cargarTablita(self):
        
        self.capaActiva = iface.activeLayer()
        self.vaciarTablita()
        
        self.comboConstEsp = QtWidgets.QComboBox()
        self.comboConstEsp.setStyleSheet("QComboBox QAbstractItemView::item { min-height: 25; font-family: 'Century Gothic';}\n"
                                        "QListView{color: black ; font-size: 16px; outline:none; font-weight:bold; font-family: 'Century Gothic';}\n"
                                        "QListView::item:selected { color: white; background-color:  rgb(250,238,224); font-family: 'Century Gothic';}\n"
                                        "QComboBox{\nbackground : rgb(255,255,255);\n}")


        
        
        header = self.dockwidget.tablaEdicion.horizontalHeader()
        #header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
        #header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
        header.setResizeContentsPrecision(100)
        header.setResizeContentsPrecision(200)
        #header.setStretchLastSection(True)
        
        self.dockwidget.labelCapaEdicion.setText('---')
        if self.capaActiva == None:
            #self.UTI.mostrarAlerta("No tienes ninguna capa activa", QMessageBox().Critical, 'Edicion de atributos')
            self.cambiarStatus("---", "error")

        else:

            self.seleccion = self.capaActiva.selectedFeatures()
            self.listaEtiquetas = []
            self.dockwidget.labelCapaEdicion.setText(self.traducirIdCapa( self.capaActiva.id()))
            
            if (len(self.seleccion) == 1):

                self.cambiarStatus("Edicion Activa", "ok")
                campos = self.capaActiva.fields()   
                nombres = [campo.name() for campo in campos]
                self.tipConst = 0

                if self.capaActiva.id() == self.obtenerIdCapa('manzana'):
                    self.listaAtributos = ['clave']
                    self.listaEtiquetas = ['Clave']
                elif self.capaActiva.id() == self.obtenerIdCapa('predios.geom'):
                    self.listaAtributos = ['clave']
                    self.listaEtiquetas = ['Clave']
                elif self.capaActiva.id() == self.obtenerIdCapa('predios.num'):
                    self.listaAtributos = ['numExt']
                    self.listaEtiquetas = ['Numero exterior']
                elif self.capaActiva.id() == self.obtenerIdCapa('construcciones'):
                    ixCveConstEsp = campos.lookupField('cve_const_esp')
                    self.tipConst = self.seleccion[0].attributes()[ixCveConstEsp]
                    headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}
                    respuesta = requests.get(self.CFG.urlTipoConstEsp, headers = headers)
                    diccionarioConst = {}
                    if respuesta.status_code == 200:
                        for clave in respuesta.json():
                            self.comboConstEsp.addItem(str(clave['cveConstEsp']) + " - " + clave['descripcion'], str(clave['cveConstEsp']) )
                            diccionarioConst[clave['cveConstEsp']] = str(clave['cveConstEsp']) + " - " + clave['descripcion']
                    else:
                        self.UTI.mostrarAlerta("No se han podido cargar los tipos de construccion especial\nError de servidor const esp", QMessageBox().Critical, "Cargar tipos de construccion especial")

                    if  self.tipConst != None:
                        self.listaAtributos = ['nom_volumen', 'cve_const_esp']
                        self.listaEtiquetas = ['Volumen', 'Tipo de construccion']
                    else:
                        self.listaAtributos = ['nom_volumen', 'num_niveles']
                        self.listaEtiquetas = ['Volumen', 'Niveles']
                elif self.capaActiva.id() == self.obtenerIdCapa('horizontales.geom'):
                    self.listaAtributos = ['clave']
                    self.listaEtiquetas = ['Clave']
                elif self.capaActiva.id() == self.obtenerIdCapa('horizontales.num'):
                    self.listaAtributos = ['num_ofi']
                    self.listaEtiquetas = ['Numero Oficial']
                elif self.capaActiva.id() == self.obtenerIdCapa('verticales'):
                    self.listaAtributos = ['clave']
                    self.listaEtiquetas = ['Clave']
                elif self.capaActiva.id() == self.obtenerIdCapa('cves_verticales'):
                    self.listaAtributos = ['clave']
                    self.listaEtiquetas = ['Clave']

                if self.capaActiva.id() == self.obtenerIdCapa('construcciones'):
                    for x in range(0, len(self.listaAtributos)):
                                
                        self.dockwidget.tablaEdicion.insertRow(x)
                        item = QtWidgets.QTableWidgetItem(self.listaEtiquetas[x])
                        self.dockwidget.tablaEdicion.setItem(x, 0 , item)#self.capaActual.getFeatures().attributes()[x])
                        item.setFlags( QtCore.Qt.ItemIsSelectable |  QtCore.Qt.ItemIsEnabled )
                        textoItem = str( self.seleccion[0][self.listaAtributos[x]])

                        if self.tipConst != None: 
                            if x == 1:
                                self.dockwidget.tablaEdicion.setCellWidget(1,1,self.comboConstEsp)
                                textito = self.seleccion[0].attributes()[ixCveConstEsp]
                                index = self.comboConstEsp.findText(diccionarioConst[textito], QtCore.Qt.MatchFixedString)
                                if index >= 0:
                                    self.comboConstEsp.setCurrentIndex(index)
                            else:

                                self.dockwidget.tablaEdicion.setItem(x, 1 , QtWidgets.QTableWidgetItem(textoItem)) 
                        else:
                            self.dockwidget.tablaEdicion.setItem(x, 1 , QtWidgets.QTableWidgetItem(textoItem))
                else:
                    for x in range(0, len(self.listaAtributos)):
                                
                        self.dockwidget.tablaEdicion.insertRow(x)
                        item = QtWidgets.QTableWidgetItem(self.listaEtiquetas[x])
                        self.dockwidget.tablaEdicion.setItem(x, 0 , item)#self.capaActual.getFeatures().attributes()[x])
                        item.setFlags( QtCore.Qt.ItemIsSelectable |  QtCore.Qt.ItemIsEnabled )
                        textoItem = str( self.seleccion[0][self.listaAtributos[x]])
                        self.dockwidget.tablaEdicion.setItem(x, 1 , QtWidgets.QTableWidgetItem(textoItem))

            else:
                self.cambiarStatus("---", "error")

        # -- abrir cedula -- 
        if self.abrePredio:

            listElim = []

            for key, value in self.dockwidget.lista.items():
                if self.dockwidget.lista[key].isVisible() == False:
                    listElim.append(key)



            for key in listElim:
                del self.dockwidget.lista[key]

            capaActiva = iface.activeLayer()
            features = []
            cond = False

            # saber cual capa esta activa, a cual se le dio click
            if capaActiva.id() == self.obtenerIdCapa('predios.geom'):
                features = self.xPredGeom.selectedFeatures()

                # validar si el predio contiene algun condominio
                condVCve = self.xCvesVert.getFeatures()
                condHori = self.xHoriGeom.getFeatures()

                # -- buscar si el predio seleccionado contiene condominios
                # -* ya sean verticales u horizontales
                for p in features:
                    geomP = p.geometry()

                    # verifica si tiene claves de verticales
                    for cv in condVCve:
                        geom = cv.geometry()
                        if geom.within(geomP):
                            cond = True
                            break

                    # verifica si tiene horizontales
                    for cv in condHori:
                        geom = cv.geometry().buffer(-0.000001,1)
                        if geom.within(geomP):
                            cond = True
                            break

            elif capaActiva.id() == self.obtenerIdCapa('horizontales.geom'):
                features = self.xHoriGeom.selectedFeatures()
                cond = True
            elif capaActiva.id() == self.obtenerIdCapa('cves_verticales'):
                features = self.xCvesVert.selectedFeatures()
                cond = True

            if len(features) == 0:
                self.cambiarStatusCedula("Seleccione una geometria", "error")
                return
            if len(features) != 1:
                self.cambiarStatusCedula("Seleccione una sola geometria", "error")
                return
            else:
                self.cambiarStatusCedula("Abriendo cedula...", "ok")

                feat = features[0]

                if len(feat['cve_cat']) < self.cve_cat_len:
                    self.UTI.mostrarAlerta('La clave catastral tiene un formato incorrecto, guarde la manzana e intente de nuevo', QMessageBox().Warning, 'Cedula Catastral')
                    return

                
                cve_recortada =  str(feat['cve_cat'][0: self.cve_cat_len])

                #validar si la clave ya existe
                for key, value in self.dockwidget.lista.items():
                    if str(key) == cve_recortada:
                        self.UTI.mostrarAlerta('La Clave: \'' + cve_recortada + '\' se encuentra abierta', QMessageBox().Information, 'Cedula Catastral')
                        self.cancelaAperturaCedula()
                        return

                # limite de cedulas abiertas
                if len(self.dockwidget.lista) == 5:
                    self.UTI.mostrarAlerta('Excedio el limite de cedulas abiertas', QMessageBox().Warning, 'Cedula Catastral')
                    return

                # abrir Cedula
                self.dockwidget.lista[cve_recortada] = CedulaMainWindow(str(feat['cve_cat']), cond = cond, CFG = self.CFG, UTI = self.UTI, cargandoRevision = False, cve_len = self.cve_cat_len)
                self.dockwidget.lista[cve_recortada].show()
                
            self.cancelaAperturaCedula()

#########################################################################################################

    def actualizarFeature(self):

        if  self.dockwidget.tablaEdicion.rowCount() > 0:       

            if self.validarEdicion():
                
                self.UTI.mostrarAlerta('Se actualizo correctamente', QMessageBox().Information, 'Edicion de atributos')
                self.cargarTablita()
            
        else:
            self.UTI.mostrarAlerta("Necesitas seleccionar una capa", QMessageBox.Warning, 'Edicion de atributos')

#############################################################################################################################

    def vaciarTablita(self):
        
        self.dockwidget.tablaEdicion.clearContents()
        self.dockwidget.tablaEdicion.setRowCount(0)
            
        for row in range(0, self.dockwidget.tablaEdicion.rowCount()):        
            self.dockwidget.tablaEdicion.removeRow(row) 

###########################################################################################################################

    def cargarTablitaRef(self):

        self.capaActiva = iface.activeLayer()
        self.vaciarTablitaRef()
        
        if self.capaActiva.id() == self.capaEnEdicion:

            self.comboTipoAs = QtWidgets.QComboBox()
            self.comboTipoVia = QtWidgets.QComboBox()
            self.comboCveVus = QtWidgets.QComboBox()

            self.comboTipoAs.clear()
            self.comboTipoVia.clear()
            self.comboCveVus.clear()

            idCapa = self.capaActiva.id()

            header = self.dockwidget.tablaEdicionRef.horizontalHeader()
            header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
            header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
            #header.setStretchLastSection(True)
            
            #self.dockwidget.labelCapaEdicionRef.setText('---')



            if idCapa != self.obtenerIdCapa('Manzanas' )and idCapa != ('Predios'):

                self.seleccion = self.capaActiva.selectedFeatures()
                self.listaEtiquetas = []
                #self.dockwidget.labelCapaEdicionRef.setText( self.traducirIdCapa( self.capaActiva.id()))
                
                if (len(self.seleccion) == 1):

                    self.cambiarStatusRef("Edicion Activa", "ok")
                    campos = self.capaActiva.fields()   
                    nombres = [campo.name() for campo in campos]
                    self.tipConst = 0

                    if self.capaActiva.id() == self.obtenerIdCapa('Area de Valor'): #Areas de valor
                        self.listaAtributos = ['valor', 'descripcion', 'cve_vus']
                        self.listaEtiquetas = ['Valor', 'Descripcion', 'vus']

                        headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}

                        respuesta = requests.get(self.CFG.urlValoresTerrenos, headers = headers)
                        self.diccCveVus = {}
                        if respuesta.status_code == 200:
                            for resp in respuesta.json():

                                self.comboCveVus.addItem(str(resp['descripcion']), str(resp['cveVus']))
                                self.diccCveVus[str(resp['cveVus'])] = str(resp['descripcion'])
                        
                        else:
                            self.UTI.mostrarAlerta("No se han podido cargar los tipos de cvevus\nError de servidor cvevus", QMessageBox().Critical, "Cargar tipos de asentamiento")


                    elif self.capaActiva.id() == self.obtenerIdCapa('Zona Uno') or self.capaActiva.id() == self.obtenerIdCapa('Zona Dos'): #Zonas
                        self.listaAtributos = ['descripcion']
                        self.listaEtiquetas = ['Descripcion']

                    elif self.capaActiva.id() == self.obtenerIdCapa('Predios'): #Zonas
                        self.listaAtributos = ['clave']
                        self.listaEtiquetas = ['Clave']

                    elif self.capaActiva.id() == self.obtenerIdCapa('Colonias'): #Codigo Postal
                        self.listaAtributos = ['cve_col', 'id_tipo_asentamiento', 'descripcion']
                        self.listaEtiquetas = ['Clave', 'Tipo de Asentamiento', 'Descripcion']

                        headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}

                        respuesta = requests.get(self.CFG.urlTipoAsentamiento, headers = headers)
                        self.comboTipoAs.addItem('NULL','Ninguno')
                        self.diccionarioTipoAs = {}
                        self.diccionarioTipoAs['NULL'] = 'Ninguno'
                        if respuesta.status_code == 200:
                            for resp in respuesta.json():

                                self.comboTipoAs.addItem(str(resp['descripcion']), str(resp['id']))
                                self.diccionarioTipoAs[str(resp['id'])] = str(resp['descripcion'])
                                
                        
                        else:
                            self.UTI.mostrarAlerta("No se han podido cargar los tipos de asentamiento\nError de servidor asentm", QMessageBox().Critical, "Cargar tipos de asentamiento")


                    elif self.capaActiva.id() == self.obtenerIdCapa('Codigo Postal'): #Colonia
                        self.listaAtributos = ['cve_cp']
                        self.listaEtiquetas = ['CP']

                    elif self.capaActiva.id() == self.obtenerIdCapa('Calles'): #Calles
                        self.listaAtributos = ['valor', 'longitud', 'id_cve_vialidad', 'tipo_vector_calle', 'calle']
                        self.listaEtiquetas = ['Valor', 'Longitud', 'Clave vialidad', 'Tipo de Vector', 'Calle']

                        headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}

                        respuesta = requests.get(self.CFG.urlTipoVialidad, headers = headers)
                        self.comboTipoVia.addItem('Ninguno','NULL')
                        self.diccionarioTipoVia = {}
                        self.diccionarioTipoVia['NULL'] = 'Ninguno'
                        if respuesta.status_code == 200:

                            for resp in respuesta.json():
                                self.comboTipoVia.addItem(str(resp['cTipoVialidad']), str(resp['id']))
                                self.diccionarioTipoVia[str(resp['id'])] = str(resp['cTipoVialidad'])

                        else:
                            self.UTI.mostrarAlerta("No se han podido cargar los tipos de asentamiento\nError de servidor tipoasent2", QMessageBox().Critical, "Cargar tipos de vialidad")


                    elif self.capaActiva.id() == self.obtenerIdCapa('Sectores'): #Sector
                        self.listaAtributos = ['clave', 'nombre']
                        self.listaEtiquetas = ['Clave', 'Nombre']
                    
                    elif self.capaActiva.id() == self.obtenerIdCapa('Localidades'): #Localidades
                        self.listaAtributos = ['clave', 'nombre']
                        self.listaEtiquetas = ['Clave', 'Nombre']
                    
                    elif self.capaActiva.id() == self.obtenerIdCapa('Secciones'): #Secciones
                        self.listaAtributos = ['clave', 'nombre']
                        self.listaEtiquetas = ['Clave', 'Nombre']

                    elif self.capaActiva.id() == self.obtenerIdCapa('Municipios'): #Municipios
                        self.listaAtributos = ['clave', 'nombre']
                        self.listaEtiquetas = ['Clave', 'Nombre']

                    elif self.capaActiva.id() == self.obtenerIdCapa('Region Catastral'): #Region Catastral
                        self.listaAtributos = ['clave', 'nombre']
                        self.listaEtiquetas = ['Clave', 'Nombre']

                    elif self.capaActiva.id() == self.obtenerIdCapa('Estado'): #Estado
                        self.listaAtributos = ['clave', 'nombre']
                        self.listaEtiquetas = ['Clave', 'Nombre']


                    for x in range(0, len(self.listaAtributos)):
                        self.dockwidget.tablaEdicionRef.insertRow(x)

                        item = QtWidgets.QTableWidgetItem(self.listaEtiquetas[x])
                        self.dockwidget.tablaEdicionRef.setItem(x, 0 , item)#self.capaActual.getFeatures().attributes()[x])
                        item.setFlags( QtCore.Qt.ItemIsSelectable |  QtCore.Qt.ItemIsEnabled )

                        textoItem = str( self.seleccion[0][self.listaAtributos[x]])

                        self.dockwidget.tablaEdicionRef.setItem(x, 1 , QtWidgets.QTableWidgetItem(textoItem))


                    if self.capaActiva.id() == self.obtenerIdCapa( 'Colonias'):

                        self.dockwidget.tablaEdicionRef.setCellWidget(1,1,self.comboTipoAs)

                        idCve = str(self.seleccion[0]['id_tipo_asentamiento'])
                        if idCve == None:
                            idCve = 'NULL'


                        textito = self.diccionarioTipoAs[idCve]
                        index = self.comboTipoAs.findText(str(textito), QtCore.Qt.MatchFixedString)
                        if index >= 0:
                            self.comboTipoAs.setCurrentIndex(index)

                    elif self.capaActiva.id() == self.obtenerIdCapa( 'Area de Valor'):

                        self.dockwidget.tablaEdicionRef.setCellWidget(2,1,self.comboCveVus)

                        idCve = str(self.seleccion[0]['cve_vus'])

                        textito = self.diccCveVus[idCve]
                        index = self.comboCveVus.findText(str(textito), QtCore.Qt.MatchFixedString)
                        if index >= 0:
                            self.comboCveVus.setCurrentIndex(index)



                    elif self.capaActiva.id() == self.obtenerIdCapa('Calles'): #Calles

                        self.dockwidget.tablaEdicionRef.setCellWidget(2,1,self.comboTipoVia)

                        idCve = str(self.seleccion[0]['id_cve_vialidad'])
                        if idCve == None or idCve == '' or idCve == 'CALLE':
                            idCve = 'NULL'

                        textito = self.diccionarioTipoVia[idCve]

                        index = self.comboTipoVia.findText(str(textito), QtCore.Qt.MatchFixedString)
                        if index >= 0:
                            self.comboTipoVia.setCurrentIndex(index)
                        
                        longitud = self.seleccion[0].geometry().length()
                        item = QtWidgets.QTableWidgetItem(str(longitud))
                        item.setFlags( QtCore.Qt.ItemIsSelectable |  QtCore.Qt.ItemIsEnabled )
                        self.dockwidget.tablaEdicionRef.setItem(1, 1 , item)
                        idCalle = self.seleccion[0]['id']

                        if not str(idCalle) in self.diccServiciosCalle.keys():
            
                            headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}

                            self.dockwidget.tablaServiciosCalles.clearContents()
                            self.dockwidget.tablaServiciosCalles.setRowCount(0)

                            if idCalle == qgis.core.NULL or idCalle is None:
                                idCalle = 0

                            idCalle = str(idCalle)

                            respuesta = requests.get(self.CFG.urlServCalle + idCalle, headers = headers)

                            if respuesta.status_code == 200:
                                datos = respuesta.json()

                                for x in range(0, len(list(datos))):

                                    self.dockwidget.tablaServiciosCalles.insertRow(x)
                                    check = QTableWidgetItem(datos[x]['descripcion'])
                                    check.setFlags(QtCore.Qt.ItemIsUserCheckable | QtCore.Qt.ItemIsEnabled)
                                    if datos[x]['disponible'] == False:
                                        check.setCheckState(QtCore.Qt.Unchecked)
                                    else:
                                        check.setCheckState(QtCore.Qt.Checked)
                                    self.dockwidget.tablaServiciosCalles.setItem(x,0,check)

                                    item2 = QTableWidgetItem(datos[x]['servicio'])
                                    self.dockwidget.tablaServiciosCalles.setItem(x,1,item2)
                        
                        else:
                            listaServicios = self.diccServiciosCalle[str(idCalle)]

                            for x in range(0, len(listaServicios)):
                                self.dockwidget.tablaServiciosCalles.insertRow(x)

                                estado = listaServicios[x][0]
                                check = QTableWidgetItem(listaServicios[x][1])
                                item2 = QTableWidgetItem(listaServicios[x][2])

                                check.setFlags(QtCore.Qt.ItemIsUserCheckable | QtCore.Qt.ItemIsEnabled)
                                if estado == '0':
                                    check.setCheckState(QtCore.Qt.Unchecked)
                                else:
                                    check.setCheckState(QtCore.Qt.Checked)

                                self.dockwidget.tablaServiciosCalles.setItem(x,0,check)
                                self.dockwidget.tablaServiciosCalles.setItem(x,1,item2)



                        header = self.dockwidget.tablaServiciosCalles.horizontalHeader()
                        
                        header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
                        header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)


                else:
                    self.cambiarStatusRef("---", "error")

            else:
                self.cambiarStatusRef("---", "error")

#########################################################################################################

    def actualizarFeatureRef(self):

        if  self.dockwidget.tablaEdicionRef.rowCount() > 0:       

            if self.validarEdicionRef():
                
                self.UTI.mostrarAlerta('Se actualizo correctamente', QMessageBox().Information, 'Edicion de atributos')
                self.cargarTablitaRef()
            
        else:
            self.UTI.mostrarAlerta("Se requiere seleccionar exactamente un elemento a editar", QMessageBox.Warning, 'Edicion de atributos')

#############################################################################################################################

    def vaciarTablitaRef(self):
        
        self.dockwidget.tablaEdicionRef.clearContents()
        self.dockwidget.tablaEdicionRef.setRowCount(0)
            
        self.dockwidget.tablaServiciosCalles.clearContents()
        self.dockwidget.tablaServiciosCalles.setRowCount(0)

        #for row in range(0, self.dockwidget.tablaEdicionRef.rowCount()):        
        #    self.dockwidget.tablaEdicionRef.removeRow(row) 

####################################################################################################################


    def cambiarStatus(self, texto, estado):

        self.dockwidget.labelStatusEdicion.setText(texto)

        
        if estado == "ok":
            estilo = """color: rgb(1, 230, 1);
"""
        elif estado == "error":
            estilo = """color: rgb(255, 0, 0);
"""
        elif estado == "warning":
            estilo = """color: rgb(255, 255, 0);
"""

        self.dockwidget.labelStatusEdicion.setStyleSheet(estilo)

############################################################################################################################

    def cambiarStatusCedula(self, texto, estado):

        self.dockwidget.lbEstatusCedula.setText(texto)

        if estado == "ok": # abriendo
            self.dockwidget.lbEstatusCedula.setStyleSheet('color: green')
        elif estado == "error": # Seleccione un solo predio
            self.dockwidget.lbEstatusCedula.setStyleSheet('color: red')
        else:
            self.dockwidget.lbEstatusCedula.setStyleSheet('color: black')



###################################################################################################################

    def cambiarStatusRef(self, texto, estado):

        self.dockwidget.labelStatusEdicionRef.setText(texto)

        #self.dockwidget.labelStatusEdicionRef.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)
        
        if estado == "ok":
            estilo = """color: rgb(1, 230, 1);
"""
        elif estado == "error":
            estilo = """color: rgb(255, 0, 0);
"""
        elif estado == "warning":
            estilo = """color: rgb(255, 255, 0);
"""

        self.dockwidget.labelStatusEdicionRef.setStyleSheet(estilo)

#########################################################################################################################

    def validarEdicion(self):

        nombreCapa = self.traducirIdCapa( self.capaActiva.id())
        feat = self.capaActiva.selectedFeatures()[0]
        banderaCompleta = True
        self.capaActiva.startEditing()

        if nombreCapa == 'manzana':
            texto = "Nada"
            
            try:
                texto = self.dockwidget.tablaEdicion.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False
            if self.UTI.esEntero(texto): #Cuando es entero
                if len(texto) == 3: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaCompleta = False
            else: #Cuando no es numerico
                banderaCompleta = False
            
            if not banderaCompleta: #Mensaje de error
                self.UTI.mostrarAlerta('La clave debe estar compuesta por exactamente 3 numeros', QMessageBox().Critical, 'Error de entrada')

        #.....predios geom....#
        elif nombreCapa == 'predios.geom':
            texto = "Nada"
            
            try:
                texto = self.dockwidget.tablaEdicion.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False
            if self.UTI.esEntero(texto): #Cuando es entero
                if len(texto) == 5: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaCompleta = False
            else: #Cuando no es numerico
                banderaCompleta = False
            
            if not banderaCompleta: #Mensaje de error
                self.UTI.mostrarAlerta('La clave debe estar compuesta por exactamente 5 numeros', QMessageBox().Critical, 'Error de entrada')

        #.....predios geom....#
        elif nombreCapa == 'predios.num':
            texto = "Nada"
            
            try:
                texto = self.dockwidget.tablaEdicion.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False

            lenText = len(texto.strip())

            if lenText < 21 and lenText > 0: #Validacion de longitud
                feat['numExt'] = texto
            else:
                banderaCompleta = False

            if not banderaCompleta: #Mensaje de error
                self.UTI.mostrarAlerta('El numero oficial no debe exceder los 20 caracteres', QMessageBox().Critical, 'Error de entrada')
        
        #.....predios geom....#
        elif nombreCapa == 'horizontales.geom':
            texto = "Nada"
            
            try:
                texto = self.dockwidget.tablaEdicion.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False
            if self.UTI.esEntero(texto): #Cuando es entero
                if len(texto) == 6: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaCompleta = False
            else: #Cuando no es numerico
                banderaCompleta = False
            
            if not banderaCompleta: #Mensaje de error
                self.UTI.mostrarAlerta('La clave debe estar compuesta por exactamente 6 numeros', QMessageBox().Critical, 'Error de entrada')    

        #.....predios geom....#
        elif nombreCapa == 'horizontales.num':
            texto = "Nada"
            
            try:
                texto = self.dockwidget.tablaEdicion.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False

            lenText = len(texto.strip())
            if lenText < 21 and lenText > 0: #Validacion de longitud
                feat['num_ofi'] = texto
            else:
                banderaCompleta = False
            
            if not banderaCompleta: #Mensaje de error
                self.UTI.mostrarAlerta('El numero oficial no debe exceder los 20 caracteres', QMessageBox().Critical, 'Error de entrada')

        #.....verticales geom....#
        elif nombreCapa == 'verticales':
            texto = "Nada"
            
            try:
                texto = self.dockwidget.tablaEdicion.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False
            if self.UTI.esEntero(texto): #Cuando es entero
                if len(texto) == 2: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaCompleta = False
            else: #Cuando no es numerico
                banderaCompleta = False
            
            if not banderaCompleta: #Mensaje de error
                self.UTI.mostrarAlerta('La clave debe estar compuesta por exactamente 2 numeros', QMessageBox().Critical, 'Error de entrada') 

        #.....clvaees verticales....#
        elif nombreCapa == 'cves_verticales':
            texto = "Nada"
            
            try:
                texto = self.dockwidget.tablaEdicion.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False
            if self.UTI.esEntero(texto): #Cuando es entero
                if len(texto) == 4: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaCompleta = False
            else: #Cuando no es numerico
                banderaCompleta = False
            
            if not banderaCompleta: #Mensaje de error
                self.UTI.mostrarAlerta('La clave debe estar compuesta por exactamente 4 numeros', QMessageBox().Critical, 'Error de entrada')


        elif nombreCapa == 'construcciones': #Con Construcciones

            bandera1 = True
              #Combo de construccion especial
            try:
                texto = self.dockwidget.tablaEdicion.item(0, 1).text()
                if len(texto) > 0 and len(texto) <=3:
                    feat['nom_volumen'] = texto
                else:
                    bandera1 = False
            except:
                bandera1 = False

            if not bandera1:
                self.UTI.mostrarAlerta('El volumen no debe exceder los 3 caracteres', QMessageBox().Critical, 'Error de entrada')
            
            bandera2 = True

            if feat['cve_const_esp'] != None:
                comboIndex2 = self.comboConstEsp.currentIndex()
                feat['cve_const_esp'] = self.comboConstEsp.itemData(comboIndex2)
                
            else:
                #try:
                texto = self.dockwidget.tablaEdicion.item(1, 1).text()
                try:
                    if len(texto) > 0 and int(texto) < 999 and self.UTI.esEntero(texto):
                        feat['num_niveles'] = texto
                    else:
                        bandera2 = False
                except:
                    bandera2 = False

            if not bandera2:
                self.UTI.mostrarAlerta('El numero de niveles debe ser numerico y no exceder 999', QMessageBox().Critical, 'Error de entrada')

            banderaCompleta = bandera1 and bandera2

        self.capaActiva.updateFeature(feat)
        self.capaActiva.triggerRepaint()
        self.capaActiva.commitChanges()

        return banderaCompleta

#####################################################################################################

    def validarEdicionRef(self):

        nombreCapa = self.traducirIdCapa( self.capaActiva.id())
        feat = self.capaActiva.selectedFeatures()[0]
        banderaCompleta = True

        self.capaActiva.setReadOnly(False)
        self.capaActiva.startEditing()

        #----------------------Area de valor------------------#
        if nombreCapa == 'Area de Valor':

            texto = "Nada"

            banderaValor = True

            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaValor = False
            if self.UTI.esFloat(texto): #Cuando es entero
                if len(texto) < 12: #Validacion de longitud
                    feat['valor'] = float(texto)
                else:
                    banderaValor = False
            else: #Cuando no es numerico
                banderaValor = False
            
            banderaDesc = True

            try:
                texto = self.dockwidget.tablaEdicionRef.item(1, 1).text()
            except: #Error al obtenre texto
                banderaDesc = False
            if len(texto) <= 256: #Validacion de longitud
                feat['descripcion'] = texto
            else:
                banderaDesc = False


            if not banderaValor:
                self.UTI.mostrarAlerta('El valor debe ser un numero decimal cuya longitud de texto no exceda 12 caracteres', QMessageBox().Critical, 'Error de entrada')

            if not banderaDesc:
                self.UTI.mostrarAlerta('La descripcion no debe exceder 256 caracteres', QMessageBox().Critical, 'Error de entrada')

            banderaCompleta = banderaValor and banderaDesc

            if banderaCompleta:
                indexCveVus = self.comboCveVus.currentIndex()
                feat['cve_vus'] = self.comboCveVus.itemData(indexCveVus)

        
        #----------------------Zona Uno------------------#
        elif nombreCapa == 'Zona Uno':

            texto = "Nada"

            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False
            if len(texto) <= 50: #Validacion de longitud
                feat['descripcion'] = texto
            else:
                banderaCompleta = False

            
            if not banderaCompleta:
                self.UTI.mostrarAlerta('La descripcion no debe exceder 50 caracteres', QMessageBox().Critical, 'Error de entrada')

        #----------------------Zona Dos------------------#
        elif nombreCapa == 'Zona Dos':

            texto = "Nada"

            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False
            if len(texto) <= 50: #Validacion de longitud
                feat['descripcion'] = texto
            else:
                banderaCompleta = False

            
            if not banderaCompleta:
                self.UTI.mostrarAlerta('La descripcion no debe exceder 50 caracteres', QMessageBox().Critical, 'Error de entrada')

        #----------------------Codigo Postal------------------#
        elif nombreCapa == 'Codigo Postal':

            texto = "Nada"

            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False
            if self.UTI.esEntero(texto): #Cuando es entero
                if len(texto) == 5: #Validacion de longitud
                    feat['cve_cp'] = texto
                else:
                    banderaCompleta = False
            else: #Cuando no es numerico
                banderaCompleta = False
            
            if not banderaCompleta:
                self.UTI.mostrarAlerta('El codigo postal debe estar compuesto por 5 numeros', QMessageBox().Critical, 'Error de entrada')

        #----------------------Colonias------------------#
        elif nombreCapa == 'Colonias':

            texto = "Nada"

            banderaClave = True
            banderaDesc = True

            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaClave = False
            if len(texto) == 4: #Validacion de longitud
                feat['cve_col'] = texto
            else:
                banderaClave = False

            
            try:
                texto = self.dockwidget.tablaEdicionRef.item(2, 1).text()
            except: #Error al obtenre texto
                banderaDesc = False
            if len(texto) <= 64: #Validacion de longitud
                feat['descripcion'] = texto
            else:
                banderaDesc = False

            if not banderaClave:
                self.UTI.mostrarAlerta('La longitud de la clave debe ser de 4 caracteres', QMessageBox().Critical, 'Error de entrada')

            if not banderaDesc:
                self.UTI.mostrarAlerta('La longitud de la descripcion no debe exceder 64 caracteres', QMessageBox().Critical, 'Error de entrada')

            banderaCompleta = banderaClave and banderaDesc

            if banderaCompleta:
                indexComboAs = self.comboTipoAs.currentIndex()
                feat['id_tipo_asentamiento'] = self.comboTipoAs.itemData(indexComboAs)
                
        
        #-------------------------Calles------------------------#
        elif nombreCapa == 'Calles':

            texto = "Nada"

            banderaTipo = True
            banderaCalle = True
            banderaValor = True

            # V A L O R 
            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaValor = False

            if self.UTI.esFloat(texto): #Cuando es entero
                if len(texto) < 12: #Validacion de longitud
                    
                    feat['valor'] = float(texto)
                    
                else:
                    banderaValor = False
            else: #Cuando no es numerico
                banderaValor = False

            # Nombre de la calle
            try:
                texto = self.dockwidget.tablaEdicionRef.item(4, 1).text()
            except: #Error al obtenre texto
                banderaCalle = False
            if len(texto) <= 256: #Validacion de longitud
                feat['calle'] = texto
            else:
                banderaCalle = False

            # Tipo de vector
            try:
                texto = self.dockwidget.tablaEdicionRef.item(3, 1).text()
            except: #Error al obtenre texto
                banderaTipo = False
            if len(texto) <= 64: #Validacion de longitud
                feat['tipo_vector_calle'] = texto
            else:
                banderaTipo = False

            if not banderaValor:
                self.UTI.mostrarAlerta('El valor debe ser decimal y no exceder los 12 caracteres de longitud', QMessageBox().Critical, 'Error de entrada')

            if not banderaCalle:
                self.UTI.mostrarAlerta('La longitud de la calle no debe exceder 256 caracteres', QMessageBox().Critical, 'Error de entrada')

            if not banderaTipo:
                self.UTI.mostrarAlerta('La longitud del tipo de vector no debe exceder 64 caracteres', QMessageBox().Critical, 'Error de entrada')

            banderaCompleta = banderaValor and banderaTipo and banderaTipo

            if banderaCompleta:
                indexComboVia = self.comboTipoVia.currentIndex()
                feat['id_cve_vialidad'] = self.comboTipoVia.itemData(indexComboVia)
                feat['c_tipo_vialidad'] = self.comboTipoVia.currentText()
                feat['longitud'] = float(self.dockwidget.tablaEdicionRef.item(1, 1).text())


        #----------------------Codigo Postal------------------#
        elif nombreCapa == 'Sectores':

            texto = "Nada"

            banderaClave = True
            banderaNom = True

            #Comparar la clave
            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaClave = False
            if self.UTI.esEntero(texto): #Cuando es entero
                if len(texto) == 3: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaClave = False
            else: #Cuando no es numerico
                banderaClave = False
            
            #Comparar el nombre
            try:
                texto = self.dockwidget.tablaEdicionRef.item(1, 1).text()
            except: #Error al obtenre texto
                banderaNom = False
            if len(texto) <= 256: #Validacion de longitud
                feat['nombre'] = texto
            else:
                banderaNom = False

            #Banderas
            if not banderaClave:
                self.UTI.mostrarAlerta('La clave debe estar compuesta por 3 numeros', QMessageBox().Critical, 'Error de entrada')

            if not banderaNom:
                self.UTI.mostrarAlerta('La longitud del nombre no debe exceder 256 caracteres', QMessageBox().Critical, 'Error de entrada')

            banderaCompleta = banderaClave and banderaNom

        #----------------------Codigo Postal------------------#
        elif nombreCapa == 'Localidades':

            texto = "Nada"

            banderaClave = True
            banderaNom = True

            #Comparar la clave
            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaClave = False
            if self.UTI.esEntero(texto): #Cuando es entero
                if len(texto) == 4: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaClave = False
            else: #Cuando no es numerico
                banderaClave = False
            
            #Comparar el nombre
            try:
                texto = self.dockwidget.tablaEdicionRef.item(1, 1).text()
            except: #Error al obtenre texto
                banderaNom = False
            if len(texto) <= 256: #Validacion de longitud
                feat['nombre'] = texto
            else:
                banderaNom = False

            #Banderas
            if not banderaClave:
                self.UTI.mostrarAlerta('La clave debe estar compuesta por 4 numeros', QMessageBox().Critical, 'Error de entrada')

            if not banderaNom:
                self.UTI.mostrarAlerta('La longitud del nombre no debe exceder 256 caracteres', QMessageBox().Critical, 'Error de entrada')

            banderaCompleta = banderaClave and banderaNom

        #----------------------Codigo Postal------------------#
        elif nombreCapa == 'Secciones':

            texto = "Nada"

            banderaClave = True
            banderaNom = True

            #Comparar la clave
            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaClave = False
            if self.UTI.esEntero(texto): #Cuando es entero
                if len(texto) == 2: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaClave = False
            else: #Cuando no es numerico
                banderaClave = False
            
            #Comparar el nombre
            try:
                texto = self.dockwidget.tablaEdicionRef.item(1, 1).text()
            except: #Error al obtenre texto
                banderaNom = False
            if len(texto) <= 64: #Validacion de longitud
                feat['nombre'] = texto
            else:
                banderaNom = False

            #Banderas
            if not banderaClave:
                self.UTI.mostrarAlerta('La clave debe estar compuesta por 2 numeros', QMessageBox().Critical, 'Error de entrada')

            if not banderaNom:
                self.UTI.mostrarAlerta('La longitud del nombre no debe exceder 64 caracteres', QMessageBox().Critical, 'Error de entrada')

            banderaCompleta = banderaClave and banderaNom

        #----------------------Codigo Postal------------------#
        elif nombreCapa == 'Municipios':

            texto = "Nada"

            banderaClave = True
            banderaNom = True

            #Comparar la clave
            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaClave = False
            if self.UTI.esEntero(texto): #Cuando es entero
                if len(texto) == 3: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaClave = False
            else: #Cuando no es numerico
                banderaClave = False
            
            #Comparar el nombre
            try:
                texto = self.dockwidget.tablaEdicionRef.item(1, 1).text()
            except: #Error al obtenre texto
                banderaNom = False
            if len(texto) <= 256: #Validacion de longitud
                feat['nombre'] = texto
            else:
                banderaNom = False

            #Banderas
            if not banderaClave:
                self.UTI.mostrarAlerta('La clave debe estar compuesta por 3 numeros', QMessageBox().Critical, 'Error de entrada')

            if not banderaNom:
                self.UTI.mostrarAlerta('La longitud del nombre no debe exceder 256 caracteres', QMessageBox().Critical, 'Error de entrada')

            banderaCompleta = banderaClave and banderaNom

        #----------------------Codigo Postal------------------#
        elif nombreCapa == 'Region Catastral':

            texto = "Nada"

            banderaClave = True
            banderaNom = True

            #Comparar la clave
            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaClave = False
            if self.UTI.esEntero(texto): #Cuando es entero
                if len(texto) == 3: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaClave = False
            else: #Cuando no es numerico
                banderaClave = False
            
            #Comparar el nombre
            try:
                texto = self.dockwidget.tablaEdicionRef.item(1, 1).text()
            except: #Error al obtenre texto
                banderaNom = False
            if len(texto) <= 64: #Validacion de longitud
                feat['nombre'] = texto
            else:
                banderaNom = False

            #Banderas
            if not banderaClave:
                self.UTI.mostrarAlerta('La clave debe estar compuesta por 3 numeros', QMessageBox().Critical, 'Error de entrada')

            if not banderaNom:
                self.UTI.mostrarAlerta('La longitud del nombre no debe exceder 64 caracteres', QMessageBox().Critical, 'Error de entrada')

            banderaCompleta = banderaClave and banderaNom

        #----------------------Codigo Postal------------------#
        elif nombreCapa == 'Estado':

            texto = "Nada"

            banderaClave = True
            banderaNom = True

            #Comparar la clave
            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaClave = False
            if self.UTI.esEntero(texto): #Cuando es entero
                if len(texto) == 2: #Validacion de longitud
                    feat['clave'] = int(texto)
                else:
                    banderaClave = False
            else: #Cuando no es numerico
                banderaClave = False
            
            #Comparar el nombre
            try:
                texto = self.dockwidget.tablaEdicionRef.item(1, 1).text()
            except: #Error al obtenre texto
                banderaNom = False
            if len(texto) <= 64: #Validacion de longitud
                feat['nombre'] = texto
            else:
                banderaNom = False


            banderaCompleta = banderaClave and banderaNom

            #Banderas
            if not banderaClave:
                self.UTI.mostrarAlerta('La clave debe estar compuesta por 2 numeros', QMessageBox().Critical, 'Error de entrada')

            if not banderaNom:
                self.UTI.mostrarAlerta('La longitud del nombre no debe exceder 64 caracteres', QMessageBox().Critical, 'Error de entrada')

        self.capaActiva.updateFeature(feat)
        self.capaActiva.triggerRepaint()
        self.capaActiva.commitChanges()
        self.capaActiva.setReadOnly(False)
        return banderaCompleta

##########################################################################################################


    def pintarCapasReferencia(self, nameCapa, bound, edicion):

        # se limpian las tablas de edicion de informacion tabular de las referencias
        self.vaciarTablitaRef()
        self.manzanaPrincipal = self.xManzana

        if self.manzanaPrincipal == None:
            self.UTI.mostrarAlerta("Debes cargar una manzana primero", QMessageBox().Critical, "Pintar capas de referencia")
            return
            
        # si la capa se encuentra vacia se toma de nuevo el valor del combo
        if nameCapa == '':
            nameCapa = self.dockwidget.comboCapaReferencia.currentText()

        idCapa = self.obtenerIdCapa(nameCapa)
        capaAPintar = QgsProject.instance().mapLayer(idCapa)

        # consume informacion del Webservice para obtener la capa
        if nameCapa == 'Construcciones':
            tabla = 'e_construccion'
        else:
            tabla = self.tablasReferencias[nameCapa]
             
        data = self.obtenerCapasDeReferencia(tabla, bound)

        vaciada = False

        # validacion para la capa en edicion
        if capaAPintar != None:
            if self.capaEnEdicion == self.obtenerIdCapa(nameCapa) and edicion == False:
                self.UTI.mostrarAlerta('La capa se encuentra en modo edicion, debes guardarla para volver a cargarla', QMessageBox().Critical, 'Cargar Capas')
            else:
                vaciada = True
                self.vaciarCapa(capaAPintar)

        if capaAPintar == None or edicion or vaciada:

            srid = QSettings().value('srid')

            if srid is None or srid == 'None':
                srid = '32614'

            inSpatialRef = osr.SpatialReference()
            inSpatialRef.ImportFromEPSG(int(srid))
            outSpatialRef = osr.SpatialReference()
            outSpatialRef.ImportFromEPSG(int(srid))
            coordTrans = osr.CoordinateTransformation(inSpatialRef, outSpatialRef)
            if not bool(data):
                self.UTI.mostrarAlerta('Error de servidor capRefr', QMessageBox().Critical, "Cargar capa de referencia")
                print('ERROR: REF000')
            

            print (data['features'])



            if data['features'] != []:

                varKeys = data['features'][0]['properties']

                keys = list(varKeys.keys())
                properties = []
                geoms = []
                for feature in data['features']:
                    geom = feature['geometry']
                    
                    if geom == None:
                        continue

                    property = feature['properties']
                    geom = json.dumps(geom)
                    geometry = ogr.CreateGeometryFromJson(geom)
                    geometry.Transform(coordTrans)
                    geoms.append(geometry.ExportToWkt())
                    l = []
                    for i in range(0, len(keys)):
                        l.append(property[keys[i]])
                    properties.append(l)


            # NO es la de calles
            if nameCapa != 'Calles':    
                if data['features'] != []:
                    fields = ""
                    for k in keys:
                        fields = fields + "&field=" + k + ":string(15)"

                    uriFigura = 'Polygon'

                    uri = str(uriFigura)+"?crs=epsg:" + str(srid) + fields + "&index=yes"
                else:
                    uri = self.obtenerCampos(nameCapa)

            else: # por si SII son calles
                stringCalles = self.obtenerCamposCalles()
                uri = stringCalles

            # valida si se debe de pintar de nuevo la capa o utilizar la que ya existe
            if capaAPintar == None:
                mem_layer = QgsVectorLayer(uri, nameCapa, 'memory')
                self.UTI.formatoCapa(nameCapa, mem_layer)
                #self.etiquetarCapa(nameCapa, mem_layer)   
            else:
                mem_layer = capaAPintar

            # EVENTOS
            mem_layer.selectionChanged.connect(self.cargarTablitaRef)

            mem_layer.committedFeaturesAdded.connect(self.committedFeaturesAdded)
            mem_layer.committedAttributeValuesChanges.connect(self.committedAttributeValuesChanges)
            mem_layer.committedGeometriesChanges.connect(self.committedGeometriesChanges)

            mem_layer.beforeCommitChanges.connect(self.beforeCommitChanges)
            mem_layer.editingStopped.connect(self.editingStopped)

            self.setearIdReferencia(nameCapa, mem_layer.id())

            mem_layer.setReadOnly(not edicion)

            if data['features'] != []:
                prov = mem_layer.dataProvider()
                feats = [ QgsFeature() for i in range(len(geoms)) ]
                for i, feat in enumerate(feats):
                    feat.setAttributes(properties[i])
                    feat.setGeometry(QgsGeometry.fromWkt(geoms[i]))

                if nameCapa != 'Manzanas' and nameCapa != 'Predios' and nameCapa != 'Construcciones':
                    prov.addFeatures(feats)
                
                else:
                    for feat in feats:
                        bandera = True
                        for manzana in self.manzanaPrincipal.getFeatures():
                            if feat.geometry().intersects(manzana.geometry()):
                                bandera = False
                                break
                        if bandera:                
                            prov.addFeatures([feat])


            etiquetaField = ""
            esExpresion = False
            colorCapa = QColor(0,0,0)
            if nameCapa == 'Estado':
                etiquetaField = 'nombre'
                colorCapa = QColor(160,224,0)
            elif nameCapa == 'Region Catastral':
                etiquetaField = 'clave'
                colorCapa = QColor(0,180,180)
            elif nameCapa == 'Municipios':
                etiquetaField = 'nombre'
                colorCapa = QColor(53,121,177)
            elif nameCapa == 'Secciones':
                etiquetaField = 'clave'
                colorCapa = QColor(210,0,0)
            elif nameCapa == 'Localidades':
                etiquetaField = 'nombre'
                #colorCapa = QColor(0,255,255)
            elif nameCapa == 'Sectores':
                etiquetaField = 'clave'
                colorCapa = QColor(131,199,255)
            elif nameCapa == 'Manzanas':
                etiquetaField = 'clave'
                colorCapa = QColor(193,90,188)
            elif nameCapa == 'Predios':
                etiquetaField = 'clave'
                colorCapa = QColor(9,222,102)
            elif nameCapa == 'Calles':
                etiquetaField = 'calle'
                colorCapa = QColor(0,255,0)
            elif nameCapa == 'Colonias':
                etiquetaField = 'descripcion'
                colorCapa = QColor(0,0,180)
            elif nameCapa == 'Codigo Postal':
                etiquetaField = 'cve_cp'
                colorCapa = QColor(255,127,0)
            elif nameCapa == 'Zona Uno':
                etiquetaField = 'descripcion'
                colorCapa = QColor(195,131,255)
            elif nameCapa == 'Zona Dos':
                etiquetaField = 'descripcion'
                colorCapa = QColor(120,0,232)
            elif nameCapa == 'Area de Valor':
                etiquetaField = 'valor'
                colorCapa = QColor(0,173,173)
            elif nameCapa.lower() == "construcciones":
                etiquetaField = " if( cve_const_esp is null, concat(nom_volumen, '\n', num_niveles), concat(nom_volumen, '\n', cve_const_esp))"
                esExpresion = True
                colorCapa = QColor(0,0,255)


            placeo = QgsPalLayerSettings.AroundPoint

            if nameCapa == 'Calles':
                placeo = QgsPalLayerSettings.Line  

            settings = QgsPalLayerSettings()
            settings.placement = placeo
            settings.fieldName = etiquetaField
            settings.enabled = True
            settings.isExpression = esExpresion
            
            settings.centroidWhole = True

            textFormat = QgsTextFormat()
            textFormat.setSize(8)
            textFormat.setNamedStyle('Bold')
            textFormat.setColor(colorCapa)

            settings.setFormat(textFormat)

            #settings.placement= QgsPalLayerSettings.OverPoint
            labeling = QgsVectorLayerSimpleLabeling(settings)

            mem_layer.setLabeling(labeling)
            mem_layer.setLabelsEnabled(True)

            mem_layer.triggerRepaint()
            root = QgsProject.instance().layerTreeRoot()
            if not edicion:
                grupo = root.findGroup('referencia')

                if grupo is None:
                    root.addGroup('referencia')

                    root = QgsProject.instance().layerTreeRoot()
                    grupo = root.findGroup('referencia')

            else:
                grupo = root.findGroup('edicion')
                if grupo is None:
                    root.addGroup('edicion')

                    root = QgsProject.instance().layerTreeRoot()
                    grupo = root.findGroup('edicion')
                
                self.capaEnEdicion = self.obtenerIdCapa(nameCapa)
                QSettings().setValue('capaRefEdicion', self.capaEnEdicion)

            if not vaciada or edicion:
                QgsProject.instance().addMapLayers([mem_layer], False)
                
                mzaNL = QgsLayerTreeLayer(mem_layer)

                # se agrega el grupo de referencia en caso de que no se tenga
                grupo.insertChildNode(0, mzaNL)

######################################################################################################

    # SE EJECUTA ANTES DE QUE SE HAGA EL COMMIT A LOS CAMBIOS (DE TODO TIPO) REALIZADOS
    def beforeCommitChanges(self):
        layer = QgsProject.instance().mapLayer(self.capaEnEdicion)

        if layer is None:
            return

        # CUANDO HUBO UNA EDICION EN ALGUN ELEMENTO DE LA CAPA
        if layer.editBuffer():
            # del data provider obtiene todas las features eliminadas
            # N O T A * en el DATA PROVIDER se encuentran todaos los features antes de ser eliminados
            #           si se consultan los features directamente del layer ya se encontraran con los cambios realizados
            ids = layer.editBuffer().deletedFeatureIds()

            listaEliminadaCompletaRef = []
            for feat in layer.dataProvider().getFeatures( QgsFeatureRequest().setFilterFids(ids)):

                campos = {}
                campos['geomWKT'] = feat.geometry().asWkt()
                campos['srid'] = 32614
                campos['nombre'] = self.tablasReferencias[layer.name()]
                atributos = {}
                nombresAtrbutos = layer.fields()   

                nombres = [campo.name() for campo in nombresAtrbutos]

                for x in range(0, len(nombres)):
                    atributo = feat.attributes()[x]
                    if str(feat.attributes()[x]) == "NULL":
                        atributo = None
                    atributos[str(nombres[x])] = atributo
                    
                campos['propiedades'] = atributos
                campos['accion'] = 'delete'

                if campos['propiedades']['id'] != None:
                    listaEliminadaCompletaRef.append(campos)


            listaTempRef = QSettings().value('listaEliminadaRef')
            for feat in listaEliminadaCompletaRef:
                listaTempRef.append(feat)
            QSettings().setValue('listaEliminadaRef', listaTempRef)

    # CUANDO SE TERMINO LA EDICION DE UNA CAPA SE OBTIENE EL ULTIMO FEATURE QUE SE AGREGO 
    # MEDIANTE LA HERRAMIENTA DE DIBUJO DEL MASTER
    def editingStopped (self):
        idF = QSettings().value('ultIdAgregado')
        if idF is None or idF != 0:
            return

        self.featuresId.append(int(idF))
        # quita los repetidos
        self.featuresId = list(set(self.featuresId))
        QSettings().setValue('ultIdAgregado', 0)


    # SE AGREGA UNA FEATURE por fuera de la herramienta del MASTER
    def committedFeaturesAdded(self, layerId, features):
        for f in features:
            self.featuresId.append(f.id())

    # SE MODIFICA UN ATRIBUTO por fuera de la herramienta del MASTER
    def committedAttributeValuesChanges(self, layerId, changedAttributesValues):
        self.featuresId.extend(list(changedAttributesValues.keys()))

    # CUANDO SE MODIFICA UNA GEOMETRIA por fuera de la herramienta del MASTER
    def committedGeometriesChanges(self, layerId, changedGeometries):
        self.featuresId.extend(list(changedGeometries.keys()))

######################################################################################################

    def obtenerCapasDeReferencia(self, egName, bound):

        index = self.dockwidget.comboCapaReferencia.currentIndex()

        token = self.UTI.obtenerToken()

        pagina = None
        itemsPagina = None

        if egName == 'e_predio':
            pagina = 0
            itemsPagina = 6000

        payload = {"nombre": egName, "epsg": 32614,"bbox": False,"pin": False,"geomWKT": bound, "epsgGeomWKT": 32614,"incluirGeom": True,"pagina": pagina,"itemsPagina": itemsPagina}

        if egName == 'e_construccion':
            payload.update({'constr': False})
        else:
            payload.update({'constr': True})

        payload = json.dumps(payload)
        headers = {'Content-Type': 'application/json', 'Authorization' : token}
        

        print(self.CFG.urlConsultaReferencia)
        print(payload)

        response = requests.post(self.CFG.urlConsultaReferencia, headers = headers, data = payload)

        if response.status_code == 200:
            data = response.content
            data = json.loads(data.decode('utf-8'))
            
            return data

        else:
            self.UTI.mostrarAlerta('Error de servidor obtenerRef', QMessageBox.Critical, 'Cargar capas de referencia')

##########################################################################################################
    
    def obtenerCampos(self, nombreCapa):

        listaCampos = {}
        listaTipos = {}

        listaCampos['Estado'] = ['clave', 'cve_cat', 'id', 'nombre']
        listaTipos['Estado'] = ['string(5)', 'string(30)', 'integer', 'string(100)']

        listaCampos['Region Catastral'] = ['clave', 'cve_cat', 'id', 'nombre']
        listaTipos['Region Catastral'] = ['string(5)', 'string(30)', 'integer', 'string(100)']

        listaCampos['Municipios'] = ['clave', 'cve_cat', 'id', 'nombre']
        listaTipos['Municipios'] = ['string(5)', 'string(30)', 'integer', 'string(100)']

        listaCampos['Secciones'] = ['clave', 'cve_cat', 'id', 'nombre']
        listaTipos['Secciones'] = ['string(5)', 'string(30)', 'integer', 'string(100)']

        listaCampos['Localidades'] = ['clave', 'cve_cat', 'id', 'nombre']
        listaTipos['Localidades'] = ['string(5)', 'string(30)', 'integer', 'string(100)']

        listaCampos['Sectores'] = ['clave', 'cve_cat', 'id', 'nombre']
        listaTipos['Sectores'] = ['string(5)', 'string(30)', 'integer', 'string(100)']

        listaCampos['Codigo Postal'] = ['cve_cp', 'id']
        listaTipos['Codigo Postal'] = ['string(5)', 'integer']

        listaCampos['Colonias'] = ['cve_col', 'descripcion', 'id', 'id_tipo_asentamiento']
        listaTipos['Colonias'] = ['string(5)', 'string(50)', 'integer', 'integer']
        
        listaCampos['Zona Uno'] = ['descripcion', 'id']
        listaTipos['Zona Uno'] = ['string(50)', 'integer']

        listaCampos['Zona Dos'] = ['descripcion', 'id']
        listaTipos['Zona Dos'] = ['string(50)', 'integer']

        listaCampos['Area de Valor'] = ['cve_vus', 'descripcion', 'id', 'valor']
        listaTipos['Area de Valor'] = ['string(10)', 'string(50)', 'integer', 'real']

        stringCapa = "Polygon?crs=epsg:" + str(QSettings().value('srid'))

        campos = listaCampos[nombreCapa]
        tipos = listaTipos[nombreCapa]

        for indice in range(0, len(campos)):

            name = campos[indice]
            tipo = tipos[indice]

            stringCapa += '&field='
            stringCapa += name + ':'
            stringCapa += tipo

        stringCapa += '&index=yes'
        
        return stringCapa



###########################################################################################################

    def obtenerCamposCalles(self):

        headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}
        respuesta = requests.post(self.CFG.urlCamposCalles, headers = headers)
        
        stringCapa = "LineString?crs=epsg:" + str(QSettings().value('srid'))

        diccionarioTipo = {}
        diccionarioTipo["STRING"] = 'string'
        diccionarioTipo["INTEGER"] = 'integer'
        diccionarioTipo["DATETIME"] = 'date'
        diccionarioTipo["NUMERIC"] = 'real'
        diccionarioTipo["SMALLINT"] = 'integer'
        diccionarioTipo["BOOLEAN"] = 'string'

        if respuesta.status_code == 200:
            datos = respuesta.json()
            
            for campo in datos:

                longitud = campo['longitud']

                name = campo['name']
                tipo = diccionarioTipo[campo['type']]

                stringCapa += '&field='
                stringCapa += name + ':'
                stringCapa += tipo

                if longitud != None:
                    stringCapa += "("+str(longitud)+")"
                
            stringCapa += '&index=yes'
            return stringCapa

        

######################################################################################################################
    
    def activarEdicion(self):
        
        ''' se usa para validar que haya una manzana cargada antes de proceder
        try:
            bound = self.obtenerBoundingBox().asWkt()
        except:
            self.UTI.mostrarAlerta('No se ha cargado ninguna Manzana', QMessageBox().Critical, 'Cargar referencia')
            return
        '''

        nombreCapa = self.dockwidget.comboCapasEdicion.currentText()
        
        root = QgsProject.instance().layerTreeRoot()
        grupoEdicion = root.findGroup('edicion')
        
        if grupoEdicion == None:
            root.insertGroup(0, 'edicion')
            grupoEdicion = root.findGroup('edicion')

        self.capaEnEdicion = self.obtenerIdCapa(nombreCapa)
        self.quitarDeGrupo(self.obtenerIdCapa(nombreCapa), 'referencia')
        self.pintarCapasReferencia(nombreCapa, None, True)
            #self.ineditarCampos(nombreCapa)

        self.dockwidget.comboCapasEdicion.setEnabled(False)
        self.dockwidget.botonActivarEdicion.setEnabled(False)
        self.dockwidget.botonActualizarRef.setEnabled(True)
        self.dockwidget.botonCancelarReferencia.setEnabled(True)

        if nombreCapa == 'Calles':
            self.dockwidget.tablaServiciosCalles.clearContents()
            self.dockwidget.tablaServiciosCalles.setVisible(True)
            self.dockwidget.botonActualizarServiciosCalles.setVisible(True)
            self.dockwidget.tituloServiciosCalles.setVisible(True)
        else:
            self.dockwidget.tablaServiciosCalles.setVisible(False)
            self.dockwidget.botonActualizarServiciosCalles.setVisible(False)
            self.dockwidget.tituloServiciosCalles.setVisible(False)


##########################################################################################################

    def quitarDeGrupo(self, idCapa, nombreGrupo):

        root = QgsProject.instance().layerTreeRoot()
        grupo = root.findGroup(nombreGrupo)

        capa = QgsProject.instance().mapLayer(idCapa)
        if capa == None:
            return

        if nombreGrupo == 'edicion':

            capa.setReadOnly(True)

        for child in grupo.children():
            if child.name() == capa.name():
                dump = child.dump()
                id = dump.split("=")[-1].strip()
                QgsProject.instance().removeMapLayer(id)
                break

##################################################################################################

    def existeCapa(self, idCapa):
        capa = QgsProject.instance().mapLayer(idCapa)
        return capa != None
    
#########################################################################################

    def guardarCapaReferencia(self):

        if QSettings().value('posibleGuardarRef') == 'True':
            idCapa = self.capaEnEdicion
            capa = QgsProject.instance().mapLayer(self.capaEnEdicion)
            listaAGuardar = []

            features = [x for x in capa.getFeatures() if x.id() in self.featuresId]

            for feat in features:

                campos = {}
                campos['geomWKT'] = feat.geometry().asWkt()
                campos['srid'] = str(QSettings().value('srid'))
                campos['nombre'] = self.tablasReferencias[self.traducirIdCapa(capa.id())]
                atributos = {}
                nombresAtrbutos = capa.fields()   

                nombres = []
                nombres = [campo.name() for campo in nombresAtrbutos]

                for x in range(0, len(nombres)):
                    if self.traducirIdCapa(idCapa) == 'Calles' and nombres[x] == 'c_tipo_vialidad':
                        continue
                    atributo = feat.attributes()[x]
                    
                    if str(feat.attributes()[x]) == "NULL":
                        atributo = None
                    atributos[str(nombres[x])] = atributo
                
                campos['propiedades'] = atributos

                if self.traducirIdCapa(idCapa) == 'Calles' and str(feat['id']) in self.diccServiciosCalle.keys():
                    listaServicios = []
                    for lista in self.diccServiciosCalle[str(feat['id'])]:
                        if lista[0] == '2':
                            listaServicios.append(lista[2])

                    campos['propiedades']['catServicios'] = listaServicios
                
                if campos['propiedades']['id'] == None:
                    campos['accion'] = 'new'
                else:
                    campos['accion'] = 'update'
                listaAGuardar.append(campos)

            # considera las eliminadas
            listaTempRef = QSettings().value('listaEliminadaRef')

            for feat in listaTempRef:
                listaAGuardar.append(feat)

            jsonParaGuardarAtributos = json.dumps(listaAGuardar)

            payload = jsonParaGuardarAtributos
            headers = {'Content-Type': 'application/json', 'Authorization' : self.UTI.obtenerToken()}
            
            try:
                response = requests.post(self.CFG.urlGuardadoRef, headers = headers, data = payload)
            
            except requests.exceptions.RequestException:
                self.UTI.mostrarAlerta("No se ha podido conectar al servidor v1", QMessageBox.Critical, "Guardar Cambios v1")#Error en la peticion de consulta
            
            if response.status_code == 200:
                QSettings().setValue('listaEliminadaRef', [])
                QSettings().setValue('posibleGuardarRef', 'False') 
                self.dockwidget.comboCapasEdicion.setEnabled(True)
                self.dockwidget.botonActivarEdicion.setEnabled(True)
                self.dockwidget.botonActualizarRef.setEnabled(False)
                self.dockwidget.botonCancelarReferencia.setEnabled(False)
                self.quitarDeGrupo(self.capaEnEdicion, 'edicion')

                xCapa = self.traducirIdCapa(self.capaEnEdicion)
                bBox = self.obtenerBoundingBox()

                if bBox is None:
                    self.pintarCapasReferencia(xCapa, None, False)
                else:
                    self.pintarCapasReferencia(xCapa, bBox.asWkt(), False)

                self.capaEnEdicion = ''
                QSettings().setValue('capaRefEdicion', self.capaEnEdicion)
                self.dockwidget.tablaServiciosCalles.setVisible(False)
                self.dockwidget.botonActualizarServiciosCalles.setVisible(False)
                self.dockwidget.tituloServiciosCalles.setVisible(False)
                if self.traducirIdCapa(idCapa) == 'Calles':
                    self.diccServiciosCalle = {}

                # se reinicia la variable que contiene los identificadores de los features modificados o agregados
                self.featuresId = []

                self.UTI.mostrarAlerta("Cambios guardados con exito", QMessageBox.Information, "Guardar Cambios")

            else:
                self.UTI.mostrarAlerta("Problemas al guardar la informaci√≥n", QMessageBox.Critical, "Guardar Cambios")
            
        else:
            # Error en la peticion de consulta
            self.UTI.mostrarAlerta("Se debe validar la topolog√≠a de las capas de referencia antes de guardar", QMessageBox.Critical, "Guardar Cambios")
            

#####################################################################################################################

    def rollbackCapa(self):

        # preguntar por la cancelacion
        mensaje = "¬øDesea detener la edici√≥n de la capa de referencia?"
        respuesta = QMessageBox.question(iface.mainWindow(), "Advertencia", mensaje, QMessageBox.Yes, QMessageBox.No)
        
        if respuesta == QMessageBox.No:
            return

        self.quitarDeGrupo(self.capaEnEdicion, 'edicion')

        traduccion = self.traducirIdCapa(self.capaEnEdicion)

        xCapa = self.traducirIdCapa(self.capaEnEdicion)
        bBox = self.obtenerBoundingBox()

        if bBox is None:
            self.pintarCapasReferencia(xCapa, None, False)
        else:
            self.pintarCapasReferencia(xCapa, bBox.asWkt(), False)

        #self.dockwidget.labelCapaEdicionRef.setText('---')
        self.dockwidget.comboCapasEdicion.setEnabled(True)
        self.dockwidget.botonActivarEdicion.setEnabled(True)
        self.dockwidget.botonActualizarRef.setEnabled(False)
        self.dockwidget.botonCancelarReferencia.setEnabled(False)
        self.dockwidget.tablaServiciosCalles.setVisible(False)
        self.dockwidget.botonActualizarServiciosCalles.setVisible(False)
        self.dockwidget.tituloServiciosCalles.setVisible(False)
        self.capaEnEdicion = ''
        QSettings().setValue('capaRefEdicion', self.capaEnEdicion)

##########################################################################################################################

    def ineditarCampos(self, nombreCapa):
        #Predios ineditables

        capa = QgsProject.instance().mapLayer(self.obtenerIdCapa(nombreCapa))
        capa.setReadOnly(False)
        campos = capa.fields()   
        nombres = [field.name() for field in campos]

        for i in range (0, len(nombres)):
            config = capa.editFormConfig()
            config.setReadOnly(i, True)
            capa.setEditFormConfig(config)

##########################################################################################################################

    def obtenerXCapas(self):

        # carga las capas en caso de no existir
        self.UTI.cargarCapaVacio()

        xMan = QSettings().value('xManzana')
        xPredG = QSettings().value('xPredGeom')
        xPredN = QSettings().value('xPredNum')
        xCon = QSettings().value('xConst')
        xHoriG = QSettings().value('xHoriGeom')
        xHoriN = QSettings().value('xHoriNum')
        xVe = QSettings().value('xVert')
        xCv = QSettings().value('xCvesVert')

        self.xManzana = QgsProject.instance().mapLayer(xMan)
        self.xPredGeom = QgsProject.instance().mapLayer(xPredG)
        self.xPredNum = QgsProject.instance().mapLayer(xPredN)
        self.xConst = QgsProject.instance().mapLayer(xCon)
        self.xHoriGeom = QgsProject.instance().mapLayer(xHoriG)
        self.xHoriNum = QgsProject.instance().mapLayer(xHoriN)
        self.xVert = QgsProject.instance().mapLayer(xVe)
        self.xCvesVert = QgsProject.instance().mapLayer(xCv)

        self.xManzana.selectionChanged.connect(self.cargarTablita)
        self.xPredGeom.selectionChanged.connect(self.cargarTablita)
        self.xPredNum.selectionChanged.connect(self.cargarTablita)
        self.xConst.selectionChanged.connect(self.cargarTablita)
        self.xHoriGeom.selectionChanged.connect(self.cargarTablita)
        self.xHoriNum.selectionChanged.connect(self.cargarTablita)
        self.xVert.selectionChanged.connect(self.cargarTablita)
        self.xCvesVert.selectionChanged.connect(self.cargarTablita)


#####################################################################################################################

    def capasCompletas(self):
        if self.xManzana == None:
            return False
        if self.xPredGeom == None:
            return False
        if self.xPredNum == None:
            return False
        if self.xConst == None:
            return False
        if self.xHoriGeom == None:
            return False
        if self.xHoriNum == None:
            return False
        if self.xVert == None:
            return False
        if self.xCvesVert == None:
            return False
        return True

##########################################################################################################################

    def traducirIdCapa(self, idCapa):

        if QSettings().value('xManzana') == idCapa:
            return 'manzana'
        elif QSettings().value('xPredGeom') == idCapa:
            return 'predios.geom'
        elif QSettings().value('xPredNum') == idCapa:
            return 'predios.num'
        elif QSettings().value('xConst') == idCapa:
            return 'construcciones'
        elif QSettings().value('xHoriGeom') == idCapa:
            return 'horizontales.geom'
        elif QSettings().value('xHoriNum') == idCapa:
            return 'horizontales.num'
        elif QSettings().value('xVert') == idCapa:
            return 'verticales'
        elif QSettings().value('xCvesVert') == idCapa:
            return 'cves_verticales'

        elif QSettings().value('xAreaValor') == idCapa:
            return 'Area de Valor'
        elif QSettings().value('xZonaUno') == idCapa:
            return 'Zona Uno'
        elif QSettings().value('xZonaDos') == idCapa:
            return 'Zona Dos'
        elif QSettings().value('xCP') == idCapa:
            return 'Codigo Postal'
        elif QSettings().value('xColonia') == idCapa:
            return 'Colonias'
        elif QSettings().value('xCalle') == idCapa:
            return 'Calles'
        elif QSettings().value('xSector') == idCapa:
            return 'Sectores'
        elif QSettings().value('xLocal') == idCapa:
            return 'Localidades'
        elif QSettings().value('xSeccion') == idCapa:
            return 'Secciones'
        elif QSettings().value('xMunicipio') == idCapa:
            return 'Municipios'
        elif QSettings().value('xRegion') == idCapa:
            return 'Region Catastral'
        elif QSettings().value('xEstado') == idCapa:
            return 'Estado'
        elif QSettings().value('xManzanasRef') == idCapa:
            return 'Manzanas'
        elif QSettings().value('xPredRef') == idCapa:
            return 'Predios'
        elif QSettings().value('xConstRef') == idCapa:
            return 'Construcciones'

        return None

###########################################################################################################################
            
    def obtenerIdCapa(self, nombreCapa):

        if nombreCapa == "manzana":
            return QSettings().value('xManzana')
        elif nombreCapa == "predios.geom":
            return QSettings().value('xPredGeom')
        elif nombreCapa == "predios.num":
            return QSettings().value('xPredNum')
        elif nombreCapa == "construcciones":
            return QSettings().value('xConst')
        elif nombreCapa == "horizontales.geom":
            return QSettings().value('xHoriGeom')
        elif nombreCapa == "horizontales.num":
            return QSettings().value('xHoriNum')
        elif nombreCapa == "verticales":
            return QSettings().value('xVert')
        elif nombreCapa == "cves_verticales":
            return QSettings().value('xCvesVert')
        elif nombreCapa == "Area de Valor":
            return QSettings().value('xAreaValor')
        elif nombreCapa == "Zona Uno":
            return QSettings().value('xZonaUno')
        elif nombreCapa == "Zona Dos":
            return QSettings().value('xZonaDos')
        elif nombreCapa == "Codigo Postal":
            return QSettings().value('xCP')
        elif nombreCapa == "Colonias":
            return QSettings().value('xColonia')
        elif nombreCapa == "Calles":
            return QSettings().value('xCalle')
        elif nombreCapa == "Sectores":
            return QSettings().value('xSector')
        elif nombreCapa == "Localidades":
            return QSettings().value('xLocal')
        elif nombreCapa == "Secciones":
            return QSettings().value('xSeccion')
        elif nombreCapa == "Municipios":
            return QSettings().value('xMunicipio')
        elif nombreCapa == "Region Catastral":
            return QSettings().value('xRegion')
        elif nombreCapa == "Estado":
            return QSettings().value('xEstado')
        elif nombreCapa == "Manzanas":
            return QSettings().value('xManzanasRef')
        elif nombreCapa == "Predios":
            return QSettings().value('xPredRef')
        elif nombreCapa == "Construcciones":
            return QSettings().value('xConstRef')
        
        return 'None'

################################################################################################

    def setearIdReferencia(self, nombreCapa, idCapa):

        if nombreCapa == "Area de Valor":
            valor = 'xAreaValor'
        elif nombreCapa == "Zona Uno":
            valor = 'xZonaUno'
        elif nombreCapa == "Zona Dos":
            valor = 'xZonaDos'
        elif nombreCapa == "Codigo Postal":
            valor = 'xCP'
        elif nombreCapa == "Colonias":
            valor = 'xColonia'
        elif nombreCapa == "Calles":
            valor = 'xCalle'
        elif nombreCapa == "Sectores":
            valor = 'xSector'
        elif nombreCapa == "Localidades":
            valor = 'xLocal'
        elif nombreCapa == "Secciones":
            valor = 'xSeccion'
        elif nombreCapa == "Municipios":
            valor = 'xMunicipio'
        elif nombreCapa == "Region Catastral":
            valor = 'xRegion'
        elif nombreCapa == "Estado":
            valor = 'xEstado'
        elif nombreCapa == "Manzanas":
            valor = 'xManzanasRef'
        elif nombreCapa == "Predios":
            valor = 'xPredRef'
        elif nombreCapa == "Construcciones":
            valor = 'xConstRef'

        QSettings().setValue(valor, idCapa)

###################################################################################################

    def actualizarServiciosCalles(self):

        if self.dockwidget.tablaEdicionRef.rowCount() > 0:       

            calleId = str(self.seleccion[0]['id'])
            tablaServicios = self.dockwidget.tablaServiciosCalles

            listaServicios = []
            for x in range(0, tablaServicios.rowCount()):

                listaServicios.append([str(tablaServicios.item(x,0).checkState()), tablaServicios.item(x,0).text(), tablaServicios.item(x,1).text()])
            
            self.diccServiciosCalle[calleId] = listaServicios

            self.UTI.mostrarAlerta("Servicios actualizados serv calles", QMessageBox.Information, 'Edicion de servicios de calles')

        else:
            self.UTI.mostrarAlerta("Se requiere seleccionar exactamente un elemento a editar", QMessageBox.Warning, 'Edicion de servicios de calles')

####################################################################################################################

###################################################################################################

    def event_planoMza(self):

        numL = 7
        if not self.validarCombox():
            self.UTI.mostrarAlerta('No se han seleccionado manzanas para cargar', QMessageBox.Critical, 'Capas de consulta')
            return

        # pintar la capas de calles y de manzanas
        try:
            bound = self.obtenerBoundingBox().asWkt()
        except:
            self.UTI.mostrarAlerta('No se ha cargado ninguna Manzana', QMessageBox().Critical, 'Cargar referencia')
            return

        self.pintarCapasReferencia('Calles', bound, False)
        self.pintarCapasReferencia('Manzanas', bound, False)

        xCalle = QgsProject.instance().mapLayer(QSettings().value('xCalle'))
        xManza = QgsProject.instance().mapLayer(QSettings().value('xManzanasRef'))
        

        layer = QgsProject.instance().mapLayer(QSettings().value('xManzana'))
         
        project = QgsProject.instance()
        manager = project.layoutManager()
        layoutName = 'Manzana'
        layouts_list = manager.printLayouts()

        # remove any duplicate layouts
        for layout in layouts_list:
            if layout.name() == layoutName:
                manager.removeLayout(layout)


        layout = QgsPrintLayout(project)
        layout.initializeDefaults()
        layout.setName(layoutName)

        # define el estilo de la pagina ('Carta' en este caso)
        pc = layout.pageCollection()
        pc.pages()[0].setPageSize('letter', QgsLayoutItemPage.Landscape)
        manager.addLayout(layout)

        # ** DISE√ëO **
        # agrega un rectangulo
        rectan = QgsLayoutItemShape (layout)
        rectan.setShapeType(QgsLayoutItemShape.Shape.Rectangle)
        rectan.attemptMove(QgsLayoutPoint(214, 8, QgsUnitTypes.LayoutMillimeters))
        rectan.attemptResize(QgsLayoutSize(57.863, 25.009, QgsUnitTypes.LayoutMillimeters))
        layout.addLayoutItem(rectan)

        # agrega un rectangulo
        rectan = QgsLayoutItemShape (layout)
        rectan.setShapeType(QgsLayoutItemShape.Shape.Rectangle)
        rectan.attemptMove(QgsLayoutPoint(214, 84.870, QgsUnitTypes.LayoutMillimeters))
        rectan.attemptResize(QgsLayoutSize(57.863, 6.635, QgsUnitTypes.LayoutMillimeters))
        layout.addLayoutItem(rectan)

        # agrega un rectangulo
        rectan = QgsLayoutItemShape (layout)
        rectan.setShapeType(QgsLayoutItemShape.Shape.Rectangle)
        rectan.attemptMove(QgsLayoutPoint(214, 91.500, QgsUnitTypes.LayoutMillimeters))
        rectan.attemptResize(QgsLayoutSize(57.863, 6.635, QgsUnitTypes.LayoutMillimeters))
        layout.addLayoutItem(rectan)

        # agrega un rectangulo
        rectan = QgsLayoutItemShape (layout)
        rectan.setShapeType(QgsLayoutItemShape.Shape.Rectangle)
        rectan.attemptMove(QgsLayoutPoint(214, 98.147, QgsUnitTypes.LayoutMillimeters))
        rectan.attemptResize(QgsLayoutSize(57.863, 6.958, QgsUnitTypes.LayoutMillimeters))
        layout.addLayoutItem(rectan)

        # agrega un rectangulo
        rectan = QgsLayoutItemShape (layout)
        rectan.setShapeType(QgsLayoutItemShape.Shape.Rectangle)
        rectan.attemptMove(QgsLayoutPoint(214, 105.118, QgsUnitTypes.LayoutMillimeters))
        rectan.attemptResize(QgsLayoutSize(57.863, 6.635, QgsUnitTypes.LayoutMillimeters))
        layout.addLayoutItem(rectan)

        # agrega un rectangulo
        rectan = QgsLayoutItemShape (layout)
        rectan.setShapeType(QgsLayoutItemShape.Shape.Rectangle)
        rectan.attemptMove(QgsLayoutPoint(214, 111.760, QgsUnitTypes.LayoutMillimeters))
        rectan.attemptResize(QgsLayoutSize(57.863, 5.912, QgsUnitTypes.LayoutMillimeters))
        layout.addLayoutItem(rectan)

        # agrega un rectangulo
        rectan = QgsLayoutItemShape (layout)
        rectan.setShapeType(QgsLayoutItemShape.Shape.Rectangle)
        rectan.attemptMove(QgsLayoutPoint(214, 117.683, QgsUnitTypes.LayoutMillimeters))
        rectan.attemptResize(QgsLayoutSize(57.863, 5.912, QgsUnitTypes.LayoutMillimeters))
        layout.addLayoutItem(rectan)

        # agrega un rectangulo
        rectan = QgsLayoutItemShape (layout)
        rectan.setShapeType(QgsLayoutItemShape.Shape.Rectangle)
        rectan.attemptMove(QgsLayoutPoint(214, 123.600, QgsUnitTypes.LayoutMillimeters))
        rectan.attemptResize(QgsLayoutSize(57.863, 5.500, QgsUnitTypes.LayoutMillimeters))
        layout.addLayoutItem(rectan)

        # agrega un rectangulo
        rectan = QgsLayoutItemShape (layout)
        rectan.setShapeType(QgsLayoutItemShape.Shape.Rectangle)
        rectan.attemptMove(QgsLayoutPoint(236.127, 123.600, QgsUnitTypes.LayoutMillimeters))
        rectan.attemptResize(QgsLayoutSize(19.094, 5.500, QgsUnitTypes.LayoutMillimeters))
        layout.addLayoutItem(rectan)

        # agrega un rectangulo
        rectan = QgsLayoutItemShape (layout)
        rectan.setShapeType(QgsLayoutItemShape.Shape.Rectangle)
        rectan.attemptMove(QgsLayoutPoint(214.000, 129.110, QgsUnitTypes.LayoutMillimeters))
        rectan.attemptResize(QgsLayoutSize(57.863, 5.912, QgsUnitTypes.LayoutMillimeters))
        layout.addLayoutItem(rectan)

        # agrega un rectangulo
        rectan = QgsLayoutItemShape (layout)
        rectan.setShapeType(QgsLayoutItemShape.Shape.Rectangle)
        rectan.attemptMove(QgsLayoutPoint(214.000, 135.024, QgsUnitTypes.LayoutMillimeters))
        rectan.attemptResize(QgsLayoutSize(57.863, 72.976, QgsUnitTypes.LayoutMillimeters))
        layout.addLayoutItem(rectan)

        # PINTA LA MANZANA (MAPA GRANDE)
        # obtiene solo el poligono que se mostrara en el mapa grande
        stringCapa = 'Polygon?crs=epsg:' + str(QSettings().value('srid')) + '&field=num:string(10)'
        layerPoly = QgsVectorLayer(stringCapa, 'polygon', 'memory')
        prov = layerPoly.dataProvider()
        geom = list(layer.getFeatures())[0].geometry()
        feat = QgsFeature()
        feat.setGeometry(geom)
        feat.setAttributes([str(1)])
        prov.addFeatures([feat])

        #QgsProject.instance().addMapLayers([layerPoly])

        # etiqueta del layer (comportamiento del texto)
        s = QgsPalLayerSettings()
        s.placement = QgsPalLayerSettings.OverPoint
        s.fieldName = "'Superficie: ' || round($area, 2) || 'm2'"
        s.enabled = True
        s.isExpression = True
        s.centroidWhole = True
        # formato del texto
        textFormat = QgsTextFormat()
        textFormat.setColor(QColor(0,0,0))
        textFormat.setSize(8)
        textFormat.setNamedStyle('Bold')
        s.setFormat(textFormat)
        # asociar el estilo con la capa
        labeling = QgsVectorLayerSimpleLabeling(s)
        layerPoly.setLabeling(labeling)
        layerPoly.setLabelsEnabled(True)
        layerPoly.triggerRepaint()
        #estilo de la geometria
        render = layerPoly.renderer()
        symbol = QgsFillSymbol.createSimple({'color':'255,0,0,0', 'color_border':'#000000', 'width_border':'0.3'})
        render.setSymbol(symbol)

        #QgsProject.instance().addMapLayers([layerPoly])

        # PINTAR LOS PUNTOS QUE INDICAN SU NUMERACION
        # obtener la geometria del poligono
        geom = list(layerPoly.getFeatures())[0].geometry()
        polygon = geom.asPolygon()
        vertices = []
        # obtiene los vertices del poligono
        n = len(polygon[0])
        for i in range(n):
            vertices.append(polygon[0][i])

        print(vertices)
            
        # creacion de la capa de puntos
        stringCapa = 'Point?crs=epsg:' + str(QSettings().value('srid')) + '&field=num:string(10)'
        layerPoint = QgsVectorLayer(stringCapa, 'point', 'memory')
        prov = layerPoint.dataProvider()

        for i, v in enumerate(vertices):
            feat = QgsFeature()
            feat.setGeometry(QgsGeometry.fromPointXY(v))
            if (i + 1) != len(vertices):
                feat.setAttributes([i+1])
            prov.addFeatures([feat])

        # etiqueta del layer (comportamiento del texto)
        s = QgsPalLayerSettings()
        s.fieldName = "num"
        s.enabled = True
        s.isExpression = True
        s.centroidWhole = True
        # formato del texto
        textFormat = QgsTextFormat()
        textFormat.setColor(QColor(0,0,0))
        textFormat.setSize(8)
        textFormat.setNamedStyle('Bold')
        s.setFormat(textFormat)
        # asociar el estilo con la capa
        labeling = QgsVectorLayerSimpleLabeling(s)
        layerPoint.setLabeling(labeling)
        layerPoint.setLabelsEnabled(True)
        layerPoint.triggerRepaint()

        #estilo de la geometria
        props = layerPoint.renderer().symbol().symbolLayer(0).properties()
        props['color'] = '#ffffff'
        symbol = QgsMarkerSymbol.createSimple({'name': 'square', 'color': '255,255,255,0', 'outline_color': '0,0,0,0'})
        layerPoint.renderer().setSymbol(symbol)

        # PINTAR LAS LINEAS QUE CONFORMAN EL POLIGONO PARA MARCAR LAS DISTANCIAS QUE HAY ENTRE SUS PUNTOS
        # creacion de la capa de lineas
        stringCapa = 'LineString?crs=epsg:' + str(QSettings().value('srid')) + '&field=num:string(10)'
        layerLine = QgsVectorLayer(stringCapa, 'line', 'memory')
        prov = layerLine.dataProvider()
        # se toma un punto y su siguiente para la creacion de la linea, asi para todo el poligono
        for i in range(len(vertices)):
            listTemp = []
            listTemp.append(vertices[i])
            # cuando no hay punto siguiente se toma en cuenta el primero para cerrar el poligono
            if (i + 1) == len(vertices): 
                listTemp.append(vertices[0])
            else:
                listTemp.append(vertices[i + 1])
            
            feat = QgsFeature()
            feat.setGeometry(QgsGeometry.fromPolylineXY(listTemp))
            feat.setAttributes([str(round(feat.geometry().length(), 2))])
            prov.addFeatures([feat])

        # etiqueta del layer (comportamiento del texto)
        s = QgsPalLayerSettings()
        s.placement = QgsPalLayerSettings.Line
        s.fieldName = 'num'
        s.enabled = True
        s.isExpression = False
        s.centroidWhole = True
        #s.displayAll = True # muestra todas las etiquetas sin importar que se empalmen
        # muestra todas las etiquetas adentro de la linea, si se empalman las muestra afuera
        s.placementFlags = QgsPalLayerSettings.BelowLine
        s.mergeLines = 1
        # formato del texto
        textFormat = QgsTextFormat()
        textFormat.setColor(QColor(0,0,0))
        textFormat.setSize(5)
        textFormat.setNamedStyle('Bold')
        s.setFormat(textFormat)
        # asociar el estilo con la capa
        labeling = QgsVectorLayerSimpleLabeling(s)
        layerLine.setLabeling(labeling)
        layerLine.setLabelsEnabled(True)
        layerLine.triggerRepaint()

        #estilo de la geometria
        render = layerLine.renderer()
        symbol = QgsLineSymbol.createSimple({'line_style':'SimpleLine', 'color':'0,0,0,0', 'width_border':'0.5'})
        render.setSymbol(symbol)

        # AGREGAR LINEAS DE CALLES SIN LINEA (SOLO LA ETIQUETA)
        # se obtiene la geometria del predio
        geom = list(layerPoly.getFeatures())[0].geometry()
        geom = geom.simplify(5) # simplificamos para que la geometria no tenga tantos puntos (desaparezcan las curvas)
        geom = geom.buffer(10, 0)  # buffer de 10 metros para encontrar las calles pegadas a √©l

        # obtener las geometrias de calles
        layers = xCalle
        calles = layers
        # se obtiene las calles que colindan a la geometria del predio
        listaTemp = []
        fCalles = list(calles.getFeatures())
        rango2 = len(fCalles)
        for i in range(0, rango2):
            f2 = fCalles[i] 
            if (f2.geometry().intersects(geom)):
                interseccion = f2.geometry().intersection(geom) # intersection() - regresa un QgsGeometry
                # se validara si la intersecion entre las dos goemetrias es menor a una longitud de 6 metros no se mostrara en el mapa
                if interseccion.length() > 6:
                    map = {}
                    map['geom'] = interseccion
                    map['nombre'] = f2['calle']
                    listaTemp.append(map)

        # creacion de la capa de calles colindantes al predio
        stringCapa = 'LineString?crs=epsg:' + str(QSettings().value('srid')) + '&field=calle:string(10)'
        layerLinestring = QgsVectorLayer(stringCapa, 'calles', 'memory')
        prov = layerLinestring.dataProvider()

        for l in listaTemp:
            feat = QgsFeature()
            feat.setGeometry(l['geom'])
            feat.setAttributes([l['nombre']])
            prov.addFeatures([feat])
        # etiqueta del layer (comportamiento del texto)
        s = QgsPalLayerSettings()
        s.placement = QgsPalLayerSettings.Line
        s.fieldName = 'calle'
        s.enabled = True
        s.isExpression = False
        s.centroidWhole = True
        s.placementFlags = QgsPalLayerSettings.BelowLine | QgsPalLayerSettings.AboveLine
        s.mergeLines = 1
        # formato del texto
        textFormat = QgsTextFormat()
        textFormat.setColor(QColor(0,0,0))
        textFormat.setSize(10)
        textFormat.setNamedStyle('Bold')
        s.setFormat(textFormat)
        # asociar el estilo con la capa
        labeling = QgsVectorLayerSimpleLabeling(s)
        layerLinestring.setLabeling(labeling)
        layerLinestring.setLabelsEnabled(True)
        layerLinestring.triggerRepaint()
        #estilo de la geometria
        render = layerLinestring.renderer()
        symbol = QgsLineSymbol.createSimple({'line_style':'SimpleLine', 'color':'0,0,0,0', 'width_border':'0.5'})
        render.setSymbol(symbol)

        #QgsProject.instance().addMapLayers([layerLinestring])

        # CREACION DEL MAPA GRANDE
        map = QgsLayoutItemMap(layout)
        map.setRect(20, 20, 20, 20)

        # define las capas a mostrar
        #map.setLayers([layerPoly, layerPoint, layerLine, layerLinestring])
        map.setLayers([layerPoly])

        # calcula el rectangulo del area que va a mostrar en el layout
        rect = list(layerPoly.getFeatures())[0].geometry().buffer(15, 0).boundingBox()
        # validacion para cuando el bbox resultante sea de manera rectancular con un largo mas grande que el ancho
        if rect.height() > rect.width():
            bbox = rect
            xmin1,ymin1,xmax1,ymax1 = bbox.buffered((rect.height() - rect.width())/2).toRectF().getCoords()
            xmin2,ymin2,xmax2,ymax2 = bbox.toRectF().getCoords()

            p1 = QgsPointXY(xmin1, ymax2)
            p2 = QgsPointXY(xmax1, ymin2)
            rect = QgsRectangle(p1,p2)

        # carga el rectanculo
        rect.scale(1.0)
        map.setExtent(rect)
        map.setBackgroundColor(QColor(255, 255, 255, 0))

        # bloquear capas (para que no se muestre otra mas que la se asigno)
        map.setKeepLayerSet(True)
        map.setKeepLayerStyles(True)

        # define el estilo del marco y lo activa
        measure = QgsLayoutMeasurement(0.30, QgsUnitTypes.LayoutMillimeters)
        map.setFrameStrokeWidth(measure)
        map.setFrameEnabled(True)

        # define el estilo del grid que aparece en el mapa
        mapGrid = QgsLayoutItemMapGrid("grid", map)
        mapGrid.setAnnotationPrecision(0)
        mapGrid.setAnnotationFrameDistance(1)
        mapGrid.setAnnotationFontColor(QColor(0, 0, 0))
        mapGrid.setIntervalX(150)
        mapGrid.setIntervalY(250)
        mapGrid.setStyle(QgsLayoutItemMapGrid.GridStyle.Cross)
        mapGrid.setCrossLength(2)
        mapGrid.setFrameStyle(QgsLayoutItemMapGrid.FrameStyle.ExteriorTicks)
        mapGrid.setAnnotationEnabled(True)
        mapGrid.setAnnotationDirection(QgsLayoutItemMapGrid.AnnotationDirection.Vertical, QgsLayoutItemMapGrid.BorderSide.Left)
        mapGrid.setAnnotationDirection(QgsLayoutItemMapGrid.AnnotationDirection.Vertical, QgsLayoutItemMapGrid.BorderSide.Right)

        # agrega el grid al mapa
        map.grids().addGrid(mapGrid)

        # define la posision y el tama√±o del mapa
        map.attemptMove(QgsLayoutPoint(8, 8, QgsUnitTypes.LayoutMillimeters))
        map.attemptResize(QgsLayoutSize(142.194, 200, QgsUnitTypes.LayoutMillimeters))

        # agrega el mapa al Layout
        layout.addLayoutItem(map)
         
        # SE AGREGA UN SEGUNDO MAPA COMO REFERENCIA DE UBICACION
        # se utiliza otra capa para agregar la referencia del predio
        layers1 = xManza
        layer1 = layers1

        # se define el dise√±o de la manzana seleccionada para el mapa de referencia
        stringCapa = 'Polygon?crs=epsg:' + str(QSettings().value('srid')) + '&field=num:string(10)'
        layerPoly2 = QgsVectorLayer(stringCapa, 'polygon', 'memory')
        prov = layerPoly2.dataProvider()
        geom = list(layer.getFeatures())[0].geometry()
        feat = QgsFeature()
        feat.setGeometry(geom)
        feat.setAttributes([str(1)])
        prov.addFeatures([feat])

        #estilo de la geometria
        render = layerPoly2.renderer()
        symbol = QgsFillSymbol.createSimple({'color':'#686868', 'color_border':'#686868', 'width_border':'0.1'})
        render.setSymbol(symbol)

        map1 = QgsLayoutItemMap(layout)
        map1.setRect(20, 20, 20, 20)

        # zoom a la capa del mapa peque√±o
        listaM = list(layer1.getFeatures())
        geometria = QgsGeometry()
        rango = len(listaM)
        geometria = listaM[0].geometry()
        for i in range(0, rango):
            geometria = geometria.combine(listaM[i].geometry())

        rect = geometria.buffer(3, 0).boundingBox() # zoom realizado
        rect.scale(1.0)
        map1.setLayers([layerPoly2, layer1])
        map1.setExtent(rect)
        map1.setBackgroundColor(QColor(255, 255, 255, 0))
        map1.setKeepLayerSet(True)
        map1.setKeepLayerStyles(True)
        measure = QgsLayoutMeasurement(0.30, QgsUnitTypes.LayoutMillimeters)
        map1.setFrameStrokeWidth(measure)
        map1.setFrameEnabled(True)
        map1.attemptMove(QgsLayoutPoint(214, 33, QgsUnitTypes.LayoutMillimeters))
        map1.attemptResize(QgsLayoutSize(57.863, 51.863, QgsUnitTypes.LayoutMillimeters))


        # agrega el segundo mapa
        layout.addLayoutItem(map1)

        complemento = ''
        for i in range(len(vertices) - 1):
            if (i + 1) == (len(vertices) - 1):
                complemento = complemento + '<tr><td>' + str(i + 1) + ' - 1</td><td>' + str(round(vertices[i].distance(vertices[0]), 2)) + '</td><td>' + '{:,.2f}'.format(round(vertices[i].x(), 2)) + '</td><td>' + '{:,.2f}'.format(round(vertices[i].y(), 2)) + '</td></tr>'
            else:
                complemento = complemento + '<tr><td>' + str(i + 1) + ' - ' + str(i + 2) + '</td><td>' + str(round(vertices[i].distance(vertices[i + 1]), 2)) + '</td><td>' + '{:,.2f}'.format(round(vertices[i].x(), 2)) + '</td><td>' + '{:,.2f}'.format(round(vertices[i].y(), 2)) + '</td></tr>'

        html = '''
        <head>
        <style>
        table {
          border-collapse: collapse;
        }

        td, th {
          border: 1px solid #dddddd;
          width: 50px;
          height: 12px;
          font-family: arial, sans-serif;
          text-align: center;
          font-size: 8px;
        }

        .font1 {
            font-family: arial;
            text-align: center;
            font-size: 10px;
        }

        </style>
        </head>
        <body>
        <table>
          <tr>
            <td colspan="4" class="font1"> CUADRO DE CONSTRUCCI√ìN </td>
          </tr>
          <tr>
            <td class="distancia1" rowspan="2">LADO<br/>EST-PV</td>
            <td class="distancia1" rowspan="2">DISTANCIA (MTS)</td>
            <td colspan="2">COORDENADAS UTM</td>
          </tr>
          <tr>
            <td style="width:60px">ESTE (X)</td>
            <td style="width:60px">NORTE (Y)</td>
          </tr>
        ''' + complemento + '''
          <tr>
            <td colspan="2">SUPERFICIE: _super_ m2</td>
            <td colspan="2">PERIMETRO: _perim_ m</td>
          </tr>
        </table>
        '''

        geomPTemp = list(layerPoly.getFeatures())[0].geometry()
        area = round(geomPTemp.area(), 2)
        peri = round(geomPTemp.length(), 2)
        html = html.replace('_super_', str('{:,.2f}'.format(area)))
        html = html.replace('_perim_', str('{:,.2f}'.format(peri)))

        layout_html = QgsLayoutItemHtml(layout)
        html_frame = QgsLayoutFrame(layout, layout_html)
        html_frame.attemptSetSceneRect(QRectF(154.145, 5.930, 60, 202.220))
        html_frame.setFrameEnabled(True)
        layout_html.addFrame(html_frame)
        layout_html.setContentMode(QgsLayoutItemHtml.ManualHtml)
        layout_html.setHtml(html)
        layout_html.loadHtml()
        html_frame.setFrameEnabled(False)


        # agregar una imagen (rosa de los vientos)
        picture = QgsLayoutItemPicture(layout)
        picture.attemptMove(QgsLayoutPoint(7.85, 7.85, QgsUnitTypes.LayoutMillimeters))
        picture.attemptResize(QgsLayoutSize(22, 22, QgsUnitTypes.LayoutMillimeters))
        picture.setPicturePath('C:/AplicacionQGIS/reporte/image4144.png')
        picture.setLinkedMap(map)
        picture.setNorthMode(QgsLayoutItemPicture.NorthMode.TrueNorth)
        layout.addLayoutItem(picture)

        # agregar una imagen (rosa de los vientos, segundo mapa)
        picture = QgsLayoutItemPicture(layout)
        picture.attemptMove(QgsLayoutPoint(261.194, 74.220, QgsUnitTypes.LayoutMillimeters))
        picture.attemptResize(QgsLayoutSize(10, 10, QgsUnitTypes.LayoutMillimeters))
        picture.setPicturePath('C:/AplicacionQGIS/reporte/image4144.png')
        picture.setLinkedMap(map1)
        picture.setNorthMode(QgsLayoutItemPicture.NorthMode.TrueNorth)
        layout.addLayoutItem(picture)

        # agregar una imagen (logo de cuautitlan)
        picture = QgsLayoutItemPicture(layout)
        picture.attemptMove(QgsLayoutPoint(214.2, 8.2, QgsUnitTypes.LayoutMillimeters))
        picture.attemptResize(QgsLayoutSize(26.407, 14.486, QgsUnitTypes.LayoutMillimeters))
        picture.setPicturePath('C:/AplicacionQGIS/reporte/Cuau_bien.jpg')
        picture.setLinkedMap(map1)
        picture.setNorthMode(QgsLayoutItemPicture.NorthMode.TrueNorth)
        layout.addLayoutItem(picture)

        # CREACION DE ETIQUETAS PARA EL LAYOUT
        title = QgsLayoutItemLabel(layout)
        title.setText('COORDINACI√ìN DE\nCATASTRO')
        title.attemptMove(QgsLayoutPoint(248, 9, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(23.194, 10.364, QgsUnitTypes.LayoutMillimeters))
        title.setFont(QFont('MS Shell Dlg 2', 8))
        title.setHAlign(Qt.AlignmentFlag.AlignCenter)
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('CROQUIS DE LOCALIZACI√ìN')
        title.attemptMove(QgsLayoutPoint(223, 28, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(36.410, 3.480, QgsUnitTypes.LayoutMillimeters))
        title.setFont(QFont('MS Shell Dlg 2', 8))
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('PLANO MANZANERO')
        title.attemptMove(QgsLayoutPoint(218, 23.5, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(30.3, 3.56, QgsUnitTypes.LayoutMillimeters))
        font = QFont('MS Shell Dlg 2', 8)
        font.setBold(True)
        title.setFont(font)
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('PROPIETARIO O POSEEDOR DEL INMUEBLE:')
        title.attemptMove(QgsLayoutPoint(214.200, 85.849, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(45.397, 2.696, QgsUnitTypes.LayoutMillimeters))
        title.setFont(QFont('MS Shell Dlg 2', 6))
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('DE LA MAZA DE LA PARRA MERCEDES')
        title.attemptMove(QgsLayoutPoint(215.493, 87.870, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(55.227, 3.560, QgsUnitTypes.LayoutMillimeters))
        font = QFont('MS Shell Dlg 2', 8)
        font.setBold(True)
        title.setFont(font)
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('CLAVE CATASTRAL:')
        title.attemptMove(QgsLayoutPoint(214.200, 91.994, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(20.491, 2.696, QgsUnitTypes.LayoutMillimeters))
        title.setFont(QFont('MS Shell Dlg 2', 6))
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('001 06 351 62 01 000A')
        title.attemptMove(QgsLayoutPoint(215.493, 94.203, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(55.227, 3.560, QgsUnitTypes.LayoutMillimeters))
        font = QFont('MS Shell Dlg 2', 8)
        font.setBold(True)
        title.setFont(font)
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('UBICACI√ìN:')
        title.attemptMove(QgsLayoutPoint(214.200, 98.408, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(13.204, 2.695, QgsUnitTypes.LayoutMillimeters))
        title.setFont(QFont('MS Shell Dlg 2', 6))
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('CALLE BELLOTTO MZA 51 LTE 62 VIV A HOY PARQUE SAN MATEO')
        title.attemptMove(QgsLayoutPoint(226.205, 98.408, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(44.989, 7.296, QgsUnitTypes.LayoutMillimeters))
        font = QFont('MS Shell Dlg 2', 8)
        font.setBold(True)
        title.setFont(font)
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('MUNICIPIO Y/O ENTIDAD FEDERATIVA:')
        title.attemptMove(QgsLayoutPoint(214.200, 105.254, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(57.813, 2.696, QgsUnitTypes.LayoutMillimeters))
        title.setFont(QFont('MS Shell Dlg 2', 6))
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('CUAUTITL√ÅN, ESTADO DE M√âXICO')
        title.attemptMove(QgsLayoutPoint(215.493, 107.950, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(55.227, 3.560, QgsUnitTypes.LayoutMillimeters))
        font = QFont('MS Shell Dlg 2', 8)
        font.setBold(True)
        title.setFont(font)
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('LEVANTO:')
        title.attemptMove(QgsLayoutPoint(214.200, 112.212, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(10.246, 2.696, QgsUnitTypes.LayoutMillimeters))
        title.setFont(QFont('MS Shell Dlg 2', 6))
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('CUAUTITL√ÅN, ESTADO DE M√âXICO')
        title.attemptMove(QgsLayoutPoint(215.493, 114.323, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(55.227, 3.560, QgsUnitTypes.LayoutMillimeters))
        font = QFont('MS Shell Dlg 2', 8)
        font.setBold(True)
        title.setFont(font)
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('DIBUJO:')
        title.attemptMove(QgsLayoutPoint(214.200, 117.883, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(57.813, 2.696, QgsUnitTypes.LayoutMillimeters))
        title.setFont(QFont('MS Shell Dlg 2', 6))
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('MTRO. HUGO PAREDEZ M√ÅRQUEZ')
        title.attemptMove(QgsLayoutPoint(215.493, 120.007, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(55.227, 3.560, QgsUnitTypes.LayoutMillimeters))
        font = QFont('MS Shell Dlg 2', 8)
        font.setBold(True)
        title.setFont(font)
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('SUPERFICIE:')
        title.attemptMove(QgsLayoutPoint(214.200, 123.567, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(13.968, 2.696, QgsUnitTypes.LayoutMillimeters))
        title.setFont(QFont('MS Shell Dlg 2', 6))
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('60.00 M2')
        title.attemptMove(QgsLayoutPoint(215.493, 125.690, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(55.227, 3.560, QgsUnitTypes.LayoutMillimeters))
        font = QFont('MS Shell Dlg 2', 8)
        font.setBold(True)
        title.setFont(font)
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('FECHA:')
        title.attemptMove(QgsLayoutPoint(236.978, 123.567, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(13.968, 2.696, QgsUnitTypes.LayoutMillimeters))
        title.setFont(QFont('MS Shell Dlg 2', 6))
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('2020-10-23')
        title.attemptMove(QgsLayoutPoint(237.694, 125.690, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(17.677, 3.560, QgsUnitTypes.LayoutMillimeters))
        font = QFont('MS Shell Dlg 2', 8)
        font.setBold(True)
        title.setFont(font)
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('ESCALA:')
        title.attemptMove(QgsLayoutPoint(256.896, 123.567, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(11.579, 2.696, QgsUnitTypes.LayoutMillimeters))
        title.setFont(QFont('MS Shell Dlg 2', 6))
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('1:100')
        title.attemptMove(QgsLayoutPoint(257.763, 125.690, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(12.956, 3.560, QgsUnitTypes.LayoutMillimeters))
        font = QFont('MS Shell Dlg 2', 8)
        font.setBold(True)
        title.setFont(font)
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('METODO DE MEDICI√ìN:')
        title.attemptMove(QgsLayoutPoint(214.200, 129.250, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(26.407, 2.696, QgsUnitTypes.LayoutMillimeters))
        title.setFont(QFont('MS Shell Dlg 2', 6))
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        title.setText('1:100')
        title.attemptMove(QgsLayoutPoint(215.493, 131.314, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(13.655, 3.560, QgsUnitTypes.LayoutMillimeters))
        font = QFont('MS Shell Dlg 2', 8)
        font.setBold(True)
        title.setFont(font)
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        texto = '''LA QUE SUSCRIBE LIC. LIZETT ORTEGA ALMANZA COORDINADORA DE CATASTRO EN EL MUNICIPIO DE CUAUTITL√ÅN, ESTADO DE M√âXICO.
        CON FUNDAMENTO EN LO ESTABLECIDO EN LOS ARTICULOS 171 FRACC. VI Y 172 DEL C√ìDIGO FINANCIERO DEL ESTADO DE M√âXICO Y MUNICIPIOS.\n\n
        QUE EN EL PADR√ìN CATASTRAL SE ENCUENTRA REGISTRADO EL PREDIO CON LA UBICACI√ìN Y MEDIDAS QUE SE MUESTRAN EN EL PLANO MANZANERO\n\n
        LOS DERECHOS CONFORME AL ARTICULO 166 DEL C√ìDIGO FINANCIERO DEL ESTADO DE M√âXICO Y MUNICIPIOS\n\n\n\n\n\n\n\n\n\n
        - EL PRESENTE PLANO NO AUTORIZA FUSI√ìN, SUBDIVISI√ìN O LOTIFICACION ALGUNA
        - EL PRESENTE PLANO NO PREJUZGA DERECHOS DE PROPIEDAD
        - EL PRESENTE PLANO NO DETERMINA INFORMACI√ìN AUTORIZADA PARA CUALQUIER TIPO DE VIALIDAD
        - EL PRESENTE PLANO MANZANERO CATASTRAL DEJA SALVO LOS DERECHOS DE TERCERAS PERSONAS\n\n\n
        '''
        title.setText(texto)
        title.attemptMove(QgsLayoutPoint(215.200, 136.576, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(55.520, 71.212, QgsUnitTypes.LayoutMillimeters))
        title.setFont(QFont('MS Shell Dlg 2', 5))
        title.setHAlign(Qt.AlignmentFlag.AlignLeft)
        layout.addLayoutItem(title)

        title = QgsLayoutItemLabel(layout)
        texto = '''C E R T I F I C A\n\n\n\n\n
        A T E N T A M E N T E\n\n\n\n
        LIC. LIZETT ORTEGA ALMANZA
        '''
        title.setText(texto)
        title.attemptMove(QgsLayoutPoint(214.200, 150.000, QgsUnitTypes.LayoutMillimeters))
        title.attemptResize(QgsLayoutSize(57.433, 40.790, QgsUnitTypes.LayoutMillimeters))
        font = QFont('MS Shell Dlg 2', 8)
        font.setBold(True)
        title.setFont(font)
        title.setHAlign(Qt.AlignmentFlag.AlignCenter)
        layout.addLayoutItem(title)

        # IMPRESION EN PDF Y PNG
        layout = manager.layoutByName(layoutName)
        exporter = QgsLayoutExporter(layout)

        fnPng = 'C:/AplicacionQGIS/reporte/layout_ejemplo.png'
        fnPdf = 'C:/AplicacionQGIS/reporte/layout_ejemplo.pdf'

        exporter.exportToImage(fnPng, QgsLayoutExporter.ImageExportSettings())
        exporter.exportToPdf(fnPdf, QgsLayoutExporter.PdfExportSettings())



        self.UTI.mostrarAlerta("Proceso concluido", QMessageBox.Information, 'Plano Manzanero')

####################################################################################################################

    # -- metodo boton de abrir cedula --
    def abrirCedula(self):
        self.cambiarStatusCedula("Seleccione un predio...", "ok")
        self.iface.actionSelect().trigger()
        self.canvas.setCursor(self.cursorRedondo)
        self.dockwidget.btnAbrirCedula.setEnabled(False)
        self.abrePredio = True

###########################################################################################################

    # -- metodo boton de cancelar apertura de cedula --
    def cancelarCedula(self):
        self.iface.actionSelect().trigger()
        self.dockwidget.btnAbrirCedula.setEnabled(True)
        self.abrePredio = False
        self.cambiarStatusCedula("Cancelado...", "")

###########################################################################################################

        # -- funcion para cancelar la apertura de la cedula --
    def cancelaAperturaCedula(self):
        self.abrePredio = False
        self.dockwidget.btnAbrirCedula.setEnabled(True)

        self.xPredGeom.removeSelection()
        self.xHoriGeom.removeSelection()
        self.xCvesVert.removeSelection()
        self.canvas.refresh()
        # regresa herramienta de seleccion normal
        self.iface.actionSelect().trigger()
        self.cambiarStatusCedula("Listo...", "ok")

#################################################################


    def segmentar(self):
        #-Irrelevante-#
        capaManzana = QgsProject.instance().mapLayersByName('manzana')[0]
        capaAux = QgsProject.instance().mapLayersByName('cves_verticales')[0]
        #capaCalles = QgsProject.instance().mapLayersByName('Calles')[0]
        
        listaM = self.pruebaObtenerManzana('manzana')
        
        self.manzanaChidotota = listaM[0]
        geomManzana = self.manzanaChidotota.geometry()


        simple = geomManzana.simplify(1)

        n   = 0
        ver = simple.vertexAt(1)
        points=[]

        while(ver != QgsPoint(0,0)):
            n +=1
            points.append(ver)
            ver=simple.vertexAt(n)

        #points.append(points[0])
        segmentos = []
        rango = len(points)
        centroides = []



        for x in range(0, rango-1):
            line_start = points[x]
            line_end = points[x+1]
            line = QgsGeometry.fromPolyline([line_start,line_end])
            feat = QgsFeature()
            feat.setGeometry(QgsGeometry(line.centroid()))
            centroides.append(feat)
            #capaAux.dataProvider().addFeatures([feat])
            #capaAux.triggerRepaint()
            #capaAux.commitChanges()

        callesColindantes = []
        listaToques = []

        listaCalles = self.pruebaObtenerCalles(geomManzana)
        #Ya con centroides

        for punto in centroides:
            
            geomPunto = punto.geometry()
            tamanoBuff = 3
            bandera = False

            while tamanoBuff <= 30:

                bufferPredio = geomPunto.buffer(tamanoBuff,16)
            
                for calle in listaCalles:
                    
                    geomCalle = calle.geometry()
                    bufferCalle = geomCalle.buffer(0.1,1)

                    if bufferCalle.intersects(bufferPredio):
                        bandera = True

                        listaToques.append(calle)

                if not bandera:
                    tamanoBuff += 1
                else:
                    distancia = 999999
                    calleElegida = QgsGeometry()
                    for calleC in listaToques:
                        geomC = calleC.geometry()
                        if geomPunto.distance(geomC) < distancia:
                            distancia = geomPunto.distance(geomC)
                            calleElegida = calleC
                    
                    #st = str(calleElegida['id']) + ' - ' +  str(calleElegida['calle'])
                        
                    if not calleElegida in callesColindantes:
                        callesColindantes.append(calleElegida)

                    tamanoBuff = 99

        return callesColindantes
        
#####################################

    def checarPrincipal(self):

        capaManzana = QgsProject.instance().mapLayersByName('manzana')[0]
        capaPuntos = QgsProject.instance().mapLayersByName('predios.num')[0]
        capaPredios = QgsProject.instance().mapLayersByName('predios.geom')[0]
        capaConstru = QgsProject.instance().mapLayersByName('construcciones')[0]
        listaCalles = self.segmentar()
        
        manzana = self.manzanaChidotota
        geomManzana = manzana.geometry()

        listaPuntosP = self.pruebaObtenerManzana('predios.num')
        listaPredios = self.pruebaObtenerManzana('predios.geom')

        relacionPredios = {}
        for puntito in listaPuntosP:
            geomPuntito = puntito.geometry()
            for predito in listaPredios:
                geomPredito = predito.geometry()
                if geomPuntito.intersects(geomPredito):
                    relacionPredios[puntito.attributes()[0]] = predito.attributes()[1]
                    break


        for punto in listaPuntosP:
            
            geomPredio = punto.geometry()

            if not geomPredio.intersects(geomManzana):
                continue

            tamanoBuff = 3
            bandera = False
            listaToques = []
            salidaCalles = []

            while tamanoBuff <= 30:

                bufferPredio = geomPredio.buffer(tamanoBuff,16)
            
                for calle in listaCalles:
                    
                    geomCalle = calle.geometry()
                    bufferCalle = geomCalle.buffer(0.1,1)

                    if bufferCalle.intersects(bufferPredio):
                        bandera = True
                        listaToques.append(calle)

                if not bandera:
                    tamanoBuff += 1
                else:
                    distancia = 999999
                    calleElegida = QgsGeometry()
                    for calleC in listaToques:
                        geomC = calleC.geometry()
                        if geomPredio.distance(geomC) < distancia:
                            distancia = geomPredio.distance(geomC)
                            calleElegida = calleC
                   
                    #if not st in callesColindantes:
                    #salidaCalles.append(st)

                    tamanoBuff = 99
        
###############################################################################################

    def pruebaObtenerManzana(self, nombreCapa):
        #Nombre de la capa de acuerdo al valor del ComboBox de capas a cargar
        
        data = self.obtenerAPintar(self.obtenerIdCapa(nombreCapa))
        
        type(data)
        srid = 32614
        inSpatialRef = osr.SpatialReference()
        inSpatialRef.ImportFromEPSG(int(srid))
        outSpatialRef = osr.SpatialReference()
        outSpatialRef.ImportFromEPSG(int(srid))
        coordTrans = osr.CoordinateTransformation(inSpatialRef, outSpatialRef)
        
        if nombreCapa != 'predios.num':
            if not bool(data):
                raise Exception('Error')

            if data['features'] == []:
                return

            varKeys = data['features'][0]['properties']

            keys = list(varKeys.keys())
            
            properties = []
            geoms = []
            for feature in data['features']:
                geom = feature['geometry']
                
                property = feature['properties']
                geom = json.dumps(geom)
                geometry = ogr.CreateGeometryFromJson(geom)
                geometry.Transform(coordTrans)
                geoms.append(geometry.ExportToWkt())

                l = []
                for i in range(0, len(keys)):
                    
                    l.append(property[keys[i]])
                    
                properties.append(l)

            feats = [ QgsFeature() for i in range(len(geoms)) ]
            for i, feat in enumerate(feats):
                feat.setGeometry(QgsGeometry.fromWkt(geoms[i]))
                feat.setAttributes(properties[i])

            return feats

        else:
            polys = []
            for feature in data:
                wkt = feature['geomNum']
                gem = QgsGeometry.fromWkt(wkt)
                polys.append(gem)

            feats = [ QgsFeature() for i in range(len(polys)) ]

            for i, feat in enumerate(feats):  
                feat.setGeometry(polys[i])
                feat.setAttributes([i])

            return feats





###

    def pruebaObtenerCalles(self, param):
        #Nombre de la capa de acuerdo al valor del ComboBox de capas a cargar
        
        geoTemp = (QgsGeometry.fromWkt(param.boundingBox().asWktPolygon())).buffer(60, 0)

        data = self.obtenerCapasDeReferencia(self.tablasReferencias['Calles'], geoTemp.asWkt())
        
        type(data)
        srid = 32614
        inSpatialRef = osr.SpatialReference()
        inSpatialRef.ImportFromEPSG(int(srid))
        outSpatialRef = osr.SpatialReference()
        outSpatialRef.ImportFromEPSG(int(srid))
        coordTrans = osr.CoordinateTransformation(inSpatialRef, outSpatialRef)
        if not bool(data):
            raise Exception('Error')

        if data['features'] == []:
            return

        varKeys = data['features'][0]['properties']

        keys = list(varKeys.keys())
        

        properties = []
        geoms = []
        for feature in data['features']:
            geom = feature['geometry']
            
            property = feature['properties']
            geom = json.dumps(geom)
            geometry = ogr.CreateGeometryFromJson(geom)
            geometry.Transform(coordTrans)
            geoms.append(geometry.ExportToWkt())

            l = []
            for i in range(0, len(keys)):
                
                l.append(property[keys[i]])
            properties.append(l)

        feats = [ QgsFeature() for i in range(len(geoms)) ]
        for i, feat in enumerate(feats):
            feat.setGeometry(QgsGeometry.fromWkt(geoms[i]))
            feat.setAttributes(properties[i])
        return feats

#---------------------------------------------------------------------------

    def cargarPrediosEnComboDividir(self, listaPredios):
        
        self.DFS.dlg.comboPredios.clear()
        lista = []
        # lista de features
        for predio in listaPredios:
            lista.append(str(predio.attributes()[1]))

        lista.sort()
        for elemento in lista:
            self.DFS.dlg.comboPredios.addItem(elemento)

#------------------------------------------------------------------

    def obtenerVertices(self, geom):
        n  = 0
        ver = geom.vertexAt(0)
        vertices=[]

        while(ver != QgsPoint(0,0)):
            n +=1
            vertices.append(ver)
            ver=geom.vertexAt(n)

        return vertices

    def obtenerVertices2(self, geom):
        polygon = geom.asPolygon()
        vertices = []

        n = len(polygon[0])

        for i in range(n):
            vertices.append(polygon[0][i])

        return vertices


#----------------------------------------------------------------------

    def crearNuevoMarcaVert(self, color):
        marcador = QgsVertexMarker(iface.mapCanvas())
        #marcador.setColor(QColor(0,255,0))
        marcador.setColor(color)
        marcador.setIconSize(5)
        marcador.setIconType(QgsVertexMarker.ICON_BOX)
        marcador.setPenWidth(3)

        return marcador

#-------------------------------------------------------------------------

    def vaciarMarcador(self, listaMarcadores):
        for marcador in listaMarcadores:
            marcador.setColor(QColor(255,255,255,0))
        listaMarcadores = []

#------------------------------------------------------------------------

    def pintarMarcador(self, listaVertices, listaMarcadores, color):
        for vertice in listaVertices:
            marcador = self.crearNuevoMarcaVert(color)
            listaMarcadores.append(marcador)
            #verticeXY = QgsPointXY(vertice.x(), vertice.y())
            marcador.setCenter(vertice)

#-------------------------------------------------------------------

    def actualizarMarcadores(self):
        capaManzana = QgsProject.instance().mapLayer(self.obtenerIdCapa('manzana'))
        capaPredios = QgsProject.instance().mapLayer(self.obtenerIdCapa('predios.geom'))
        capaConst = QgsProject.instance().mapLayer(self.obtenerIdCapa('construcciones'))

        if self.dockwidget.checkVertManzana.isChecked():
            for feat in capaManzana.getFeatures():
                geom = feat.geometry()
                vertices = self.obtenerVertices2(geom)
                self.pintarMarcador(vertices, self.verticesManzana, QColor(255,0,0))
        else:
            self.vaciarMarcador(self.verticesManzana)

        if self.dockwidget.checkVertPredio.isChecked():
            for feat in capaPredios.getFeatures():
                geom = feat.geometry()
                vertices = self.obtenerVertices2(geom)
                self.pintarMarcador(vertices, self.verticesPredio, QColor(0,255,0))
        else:
            self.vaciarMarcador(self.verticesPredio)

        
        if self.dockwidget.checkVertConst.isChecked():
            for feat in capaConst.getFeatures():
                geom = feat.geometry()
                color = QColor(0,0,0)

                # validacion para que pinte los colores del las construcciones especiales
                if isinstance(feat['cve_const_esp'], str):
                    color = QColor(0,255,255)

                vertices = self.obtenerVertices2(geom)
                self.pintarMarcador(vertices, self.verticesConst, color)
        else:
            self.vaciarMarcador(self.verticesConst)
            