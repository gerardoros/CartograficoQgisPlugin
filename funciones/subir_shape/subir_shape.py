# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SubirShape
                                 A QGIS plugin
 Modulo para subir shp a postgres
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-09-09
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Oliver
        email                : foo@bar.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QVariant
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction, QFileDialog, QMessageBox
from qgis.core import *
from functools import partial

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .subir_shape_dialog import SubirShapeDialog
import os.path
import json
import requests
import os


class SubirShape:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'SubirShape_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Subir Shape')
        self.dlg = SubirShapeDialog(parent=iface.mainWindow())
        self.lyrPropertiesDict = {}

        # eventos
        self.dlg.cargarButton.clicked.connect(self.cargar)
        self.dlg.altaButton.clicked.connect(self.alta)
        self.dlg.btnBrowse.clicked.connect(partial(self.selectShape, context="shp"))
        self.dlg.btnBrowse_2.clicked.connect(partial(self.selectShape, context="shx"))
        self.dlg.btnBrowse_3.clicked.connect(partial(self.selectShape, context="dbf"))
        self.dlg.btnBrowse_4.clicked.connect(partial(self.selectShape, context="prj"))
        self.dlg.btnEdit.clicked.connect(self.editLayer)
        self.dlg.btnLoadCapa.clicked.connect(self.cargarCapa)
        self.dlg.btnConmutarABD.clicked.connect(self.conmutar)
        self.iface.currentLayerChanged.connect(self.cambiarSeleccion)


        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('SubirShape', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/subir_shape/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Subir shape'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Subir Shape'),
                action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Run method that performs all the real work"""

        # show the dialog
        self.dlg.show()
        self.llenarComboCapas()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def cargar(self):

        path = self.dlg.fldRutaShp.text()
        nomCapa = self.dlg.fldNomCapa.text()
        vlayer = QgsVectorLayer(path, nomCapa, "ogr")
        if not vlayer.isValid():
            self.UTI.mostrarAlerta(f"La capa {capa['name']} no se pudo cargar!", QMessageBox.Critical,
                                   "Alta de capa")
        else:
            QgsProject.instance().addMapLayer(vlayer)

        self.dlg.altaButton.setEnabled(True)

        # layerList = QgsProject.instance().layerTreeRoot().findLayers()
        #
        # list_to_json = []
        #
        # for layer in layerList:
        #     res = self.genera_json(layer.name(), layer.layer())
        #     list_to_json.extend(res)
        #
        # jsonParaGuardarAtributos = json.dumps(list_to_json)
        #
        # self.alta_capa(jsonParaGuardarAtributos)
        # QgsProject.instance().removeAllMapLayers()

    def llenarComboCapas(self):

        url = self.CFG.urlComboShapes

        res = None

        headers = {'Authorization': self.UTI.obtenerToken()}
        try:
            response = requests.get(url, headers=headers)

            if response:

                if response.status_code == 200:
                    res = response.json()
                elif response.status_code == 400:
                    self.UTI.mostrarAlerta(f"Error 400", QMessageBox.Critical,
                                           "Llenas combo capas")
                else:
                    self.UTI.mostrarAlerta(f"Error no manejado: {response.status_code}", QMessageBox.Critical,
                                           "Llenas combo capas")
            else:
                self.UTI.mostrarAlerta("Error del servidor, no respuesta.", QMessageBox.Critical,
                                       "Llenas combo capas")

        except requests.exceptions.RequestException:
            self.UTI.mostrarAlerta("No se ha podido conectar al servidor v1", QMessageBox.Critical,
                                   "Llenas combo capas")  # Error en la peticion de consulta

        self.dlg.comboCapas.clear()
        for lyr in res:
            self.dlg.comboCapas.addItem(lyr['name'], (lyr['internalName'], lyr['fields']))

    def cargarCapa(self):
        internalName = self.dlg.comboCapas.currentData()[0]
        lyrFields = self.dlg.comboCapas.currentData()[1]
        url = self.CFG.urlCargarCapaByName
        res = None

        headers = {'Authorization': self.UTI.obtenerToken()}
        try:
            response = requests.get(url + internalName, headers=headers)

            if response:

                if response.status_code == 200:
                    res = response.json()
                elif response.status_code == 400:
                    self.UTI.mostrarAlerta(f"Error 400", QMessageBox.Critical,
                                           "Cargar capa")
                else:
                    self.UTI.mostrarAlerta(f"Error no manejado: {response.status_code}", QMessageBox.Critical,
                                           "Cargar capa")
            else:
                self.UTI.mostrarAlerta("Error del servidor, no respuesta.", QMessageBox.Critical,
                                       "Cargar capa")

        except requests.exceptions.RequestException:
            self.UTI.mostrarAlerta("No se ha podido conectar al servidor v1", QMessageBox.Critical,
                                   "Cargar capa")  # Error en la peticion de consulta

        if res['features']:

            featIds = []
            for feat in res['features']:
                feat['properties']['id'] = feat['id']
                featIds.append(feat['id'])

            if internalName in self.lyrPropertiesDict:
                stored = self.lyrPropertiesDict[internalName]
                root = QgsProject.instance().layerTreeRoot()
                layerOpt = root.findLayer(stored['id'])
                if layerOpt:
                    layer = layerOpt.layer()
                    QgsProject.instance().removeMapLayer(layer)
                else:
                    self.lyrPropertiesDict.pop(internalName)

            vlayer = QgsVectorLayer(json.dumps(res), self.dlg.comboCapas.currentText(), "ogr")
            crs = vlayer.crs()
            crs.createFromId(int(QSettings().value("srid")))
            vlayer.setCrs(crs)
            vlayer = QgsProject.instance().addMapLayer(vlayer)

            extent = vlayer.extent()
            vlayer.setCustomProperty('internal', internalName)
            self.iface.mapCanvas().setExtent(extent)
            self.iface.mapCanvas().refresh()

            # guardamos informacion de la capa cargada
            self.lyrPropertiesDict[internalName] = {'featIds': featIds,
                                                    'lyrFields': lyrFields,
                                                    'editable': False,
                                                    'id': vlayer.id()}
            self.dlg.btnConmutarABD.setEnabled(False)
        else:
            self.UTI.mostrarAlerta("Capa sin features", QMessageBox.Critical,
                                   "Cargar capa")  # Error en la peticion de consulta

    def editLayer(self):
        layer = self.iface.activeLayer()
        if layer:
            self.creaEditable(layer)
            self.dlg.btnConmutarABD.setEnabled(True)
        else:
            self.UTI.mostrarAlerta("Selecciona una capa", QMessageBox.Critical,
                                   "Editar capa")

    def creaEditable(self, layer):

        features = list(layer.getFeatures())
        tipoGeom = QgsWkbTypes.displayString(features[0].geometry().wkbType())

        fieldsStr = self.fieldsHelper(layer)

        vlayer = QgsVectorLayer(f"{tipoGeom}?crs=epsg:{str(QSettings().value('srid'))}&{fieldsStr}&index=yes'",
                                layer.name(), 'memory')
        vlayer.startEditing()
        vlayer.dataProvider().addFeatures(features)
        vlayer.commitChanges()
        vlayer = QgsProject.instance().addMapLayer(vlayer)
        vlayer.setCustomProperty('internal', layer.customProperty('internal'))
        self.setColumnVisibility(vlayer, 'id', False)

        internamName = layer.customProperty('internal')
        if internamName in self.lyrPropertiesDict:
            properties = self.lyrPropertiesDict[internamName]
            properties['id'] = vlayer.id()
            properties['editable'] = True
            self.lyrPropertiesDict[internamName] = properties

        QgsProject.instance().removeMapLayer(layer)

    def fieldsHelper(self, layer):
        fieldsStr = []
        for field in layer.fields().toList():
            fieldsStr.append(f"field={field.name()}:{field.typeName().lower()}")
        return "&".join(fieldsStr)

    def setColumnVisibility(self, layer, columnName, visible):
        config = layer.attributeTableConfig()
        columns = config.columns()
        for column in columns:
            if column.name == columnName:
                column.hidden = not visible
                break
        config.setColumns(columns)
        layer.setAttributeTableConfig(config)

    def alta(self):

        _shp = open(self.dlg.fldRutaShp.text(), 'rb')
        _shx = open(self.dlg.fldRutaShx.text(), 'rb')
        _dbf = open(self.dlg.fldRutaDbf.text(), 'rb')
        _prj = open(self.dlg.fldRutaPrj.text(), 'rb')

        payload = {"nameLayer": self.dlg.fldNomCapa.text()}
        files = [
            ('shape', (os.path.basename(_shp.name), _shp, 'application/octet-stream')),
            ('shx', (os.path.basename(_shx.name), _shx, 'application/octet-stream')),
            ('prj', (os.path.basename(_prj.name), _prj, 'application/octet-stream')),
            ('dbf', (os.path.basename(_dbf.name), _dbf, 'application/octet-stream')),
        ]
        self.alta_capa(payload, files)
        self.llenarComboCapas()

    def selectShape(self, context):

        if context == "shp":
            header = "Selecciona el archivo .shp"
            _filter = "Shapefiles(*.shp)"
        elif context == "shx":
            header = "Selecciona el archivo .shx"
            _filter = "Shapefiles(*.shx)"
        elif context == "dbf":
            header = "Selecciona el archivo .dbf"
            _filter = "Shapefiles(*.dbf)"
        else:
            header = "Selecciona el archivo .prj"
            _filter = "Shapefiles(*.prj)"

        options = QFileDialog.Options()
        options |= QFileDialog.AnyFile
        filename = QFileDialog.getOpenFileName(self.dlg, header, filter=_filter, options=options)
        if filename:
            if context == "shp":
                self.dlg.fldRutaShp.setText(filename[0])
            elif context == "shx":
                self.dlg.fldRutaShx.setText(filename[0])
            elif context == "dbf":
                self.dlg.fldRutaDbf.setText(filename[0])
            else:
                self.dlg.fldRutaPrj.setText(filename[0])

    def alta_capa(self, payload, files=[]):

        url = self.CFG.urlAltaPorShape
        headers = {'Authorization': self.UTI.obtenerToken()}
        try:
            response = requests.post(url, headers=headers, data=payload, files=files)

            if response:

                if response.status_code in [200, 400]:
                    self.UTI.mostrarAlerta(response.json()['message'], QMessageBox.Information,
                                           "Alta de capa")
                else:
                    self.UTI.mostrarAlerta(f"Error no manejado: {response.status_code}", QMessageBox.Critical,
                                           "Alta de capa")
            else:
                self.UTI.mostrarAlerta("Error del servidor, no respuesta.", QMessageBox.Critical,
                                       "Alta de capa")

        except requests.exceptions.RequestException:
            self.UTI.mostrarAlerta("No se ha podido conectar al servidor v1", QMessageBox.Critical,
                                   "Guardar Cambios v1")  # Error en la peticion de consulta

    def cambiarSeleccion(self):

        layer = self.iface.activeLayer()
        if layer:
            internamName = layer.customProperty('internal')
            if internamName in self.lyrPropertiesDict:
                properties = self.lyrPropertiesDict[internamName]
                self.dlg.btnConmutarABD.setEnabled(properties['editable'])

    # {'featIds': featIds,
    #  'lyrFields': lyrFields,
    #  'editable': False,
    #  'id': vlayer.id()}

    def conmutar(self):
        url = self.CFG.urlConmutar
        layer = self.iface.activeLayer()
        internamName = layer.customProperty('internal')
        if internamName in self.lyrPropertiesDict:
            properties = self.lyrPropertiesDict[internamName]
            idsCurrent = [feature['id'] for feature in layer.getFeatures()]
            idsDeleted = [id for id in properties['featIds'] if id not in idsCurrent]
            idsNew = [id for id in idsCurrent if id not in properties['featIds']]
            features = []

            for id in idsDeleted:
                features.append({'accion': "DELETE",
                                 'id':id,
                                 'conceptos': [],
                                 'feature': {'geometry':{"type":"Polygon",
                                                         "coordinates":[]}}})

            for feature in layer.getFeatures():

                # ACCION
                if feature['id'] in idsDeleted:
                    accion = "DELETE"
                elif feature['id'] in idsNew:
                    accion = "NEW"
                else:
                    accion = "UPDATE"

                # CONCEPTOS
                conceptos = []
                for field in properties['lyrFields']:

                    if type(feature[field['name']]) == QVariant:
                        value = feature[field['name']].value()
                    else:
                        value = feature[field['name']]

                    concepto = {'type': field['type'],
                                'name': field['name'],
                                'value': value}
                    conceptos.append(concepto)

                # GEOMETRY
                featureGeom = {'geometry': json.loads(feature.geometry().asJson())}

                #ID
                if type(feature['id']) == QVariant:
                    id = None if feature['id'].isNull() else feature['id'].value()
                else:
                    id = feature['id']

                features.append({'accion': accion,
                                 'id':id,
                                 'conceptos': conceptos,
                                 'feature': featureGeom})
            payload = json.dumps({'features': features,
                                  'layerName': internamName})

            print(payload)

            headers = {'Content-Type': 'application/json', 'Authorization': self.UTI.obtenerToken()}
            try:
                response = requests.put(url, headers=headers, data=payload)

                if response:

                    if response.status_code == 200:

                        self.UTI.mostrarAlerta("Actualizaion exitosa", QMessageBox.Information,
                                               "Conmutar")
                    else:
                        self.UTI.mostrarAlerta(f"Error de peticion. Codigo:{response.status_code}",
                                               QMessageBox.Critical,
                                               "Conmutar")
                else:
                    self.UTI.mostrarAlerta("Error del servidor, no respuesta.", QMessageBox.Critical,
                                           "Conmutar")

            except requests.exceptions.RequestException:
                self.UTI.mostrarAlerta("No se ha podido conectar al servidor", QMessageBox.Critical,
                                       "Conmutar")  # Error en la peticion de consulta


        else:
            self.UTI.mostrarAlerta("No es posible conmutar esta capa. Asegurate de que selecionaste "
                                   "una capa cargada con este widget.", QMessageBox.Critical,
                                   "Conmutar")




    def genera_json(self, idCapa, capa):

        listaAGuardar = []
        features = [f for f in capa.getFeatures()]
        print(f"NUMERO DE FEATURES: {len(features)}")
        for i, feat in enumerate(features):

            # poly = QgsGeometry.polygonize([feat.geometry()])
            # for i, sub in enumerate(poly.asMultiPolygon()):
            #     print(f"{i} - {sub}")

            geom = feat.geometry()
            parts = [p for p in geom.parts()]
            poly = parts[0]

            campos = {}
            campos['wkt'] = poly.asWkt()
            campos['srid'] = QSettings().value('srid')
            campos['tabla'] = capa.name()
            atributos = {}
            nombresAtrbutos = capa.fields()

            if idCapa == 'horizontales.geom':
                punto = self.exteriorCondom(feat.geometry())
                if punto != None:
                    atributos['num_ofi'] = punto['num_ofi']
                    atributos['geom_num'] = punto.geometry().asWkt()

            # elif idCapa == 'predios.geom':
            #     punto = self.exteriorPredio(feat.geometry())
            #     if punto != None:
            #         atributos['numExt'] = punto['numExt']
            #         atributos['geom_num'] = punto.geometry().asWkt()

            for x, campo in enumerate(nombresAtrbutos):
                atributo = feat.attributes()[x]
                if str(atributo) == "NULL":
                    atributo = None

                if idCapa == 'manzana':
                    if campo.name() == "MZN":
                        atributos["clave"] = atributo
                    elif campo.name() == "Clave":
                        atributos["cve_cat"] = atributo
                    else:
                        atributos[campo.name()] = atributo
                elif idCapa == "predios.geom":
                    if campo.name() == "Fecha":
                        continue
                    else:
                        atributos[campo.name()] = atributo

                else:
                    atributos[campo.name()] = atributo

                campos['nuevo'] = True
                campos['eliminado'] = False

            campos['attr'] = atributos
            listaAGuardar.append(campos)
        return listaAGuardar

    def genera_json_ref(self, idCapa, capa):

        listaAGuardar = []

        for feat in capa.getFeatures():

            geom = feat.geometry()

            if geom.isMultipart():
                parts = []
                for p in geom.constParts():
                    if QgsWkbTypes.hasZ(p.wkbType()):
                        p.dropZValue()
                        parts.append(p)
                    else:
                        parts.append(p)

                poly = parts[0]
            else:
                poly = geom

            campos = {}
            campos['geomWKT'] = poly.asWkt()
            campos['srid'] = str(QSettings().value('srid'))
            campos['nombre'] = self.UTI.tablas[capa.name()]
            atributos = {}

            nombres = [campo.name() for campo in capa.fields()]

            for x, nombre in enumerate(nombres):
                if self.ACA.traducirIdCapa(idCapa) == 'Calles' and nombre == 'c_tipo_vialidad':
                    continue
                atributo = feat.attributes()[x]

                if str(atributo) == "NULL":
                    atributo = None
                atributos[nombre] = atributo

            campos['propiedades'] = atributos

            if self.ACA.traducirIdCapa(idCapa) == 'Calles':
                # if self.ACA.traducirIdCapa(idCapa) == 'Calles' and str(feat['id']) in self.diccServiciosCalle.keys():
                listaServicios = []
                for lista in self.diccServiciosCalle[str(feat['id'])]:
                    if lista[0] == '2':
                        listaServicios.append(lista[2])

                campos['propiedades']['catServicios'] = listaServicios

            if not campos['propiedades'].get("id"):
                campos['accion'] = 'new'
            else:
                campos['accion'] = 'update'
            listaAGuardar.append(campos)

        return listaAGuardar
